/*! For license information please see 46709.1b8624de78.chunk.js.LICENSE.txt */
!function(){try{var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},t=(new e.Error).stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="a766083a-a872-4550-9657-99ee20dd29b5",e._sentryDebugIdIdentifier="sentry-dbid-a766083a-a872-4550-9657-99ee20dd29b5")}catch(e){}}();var _global="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};_global.SENTRY_RELEASE={id:"5.5.0 (2024112814)"},(self.webpackChunkweb=self.webpackChunkweb||[]).push([[46709],{878918:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.s16=t.s8=t.nu64be=t.u48be=t.u40be=t.u32be=t.u24be=t.u16be=t.nu64=t.u48=t.u40=t.u32=t.u24=t.u16=t.u8=t.offset=t.greedy=t.Constant=t.UTF8=t.CString=t.Blob=t.Boolean=t.BitField=t.BitStructure=t.VariantLayout=t.Union=t.UnionLayoutDiscriminator=t.UnionDiscriminator=t.Structure=t.Sequence=t.DoubleBE=t.Double=t.FloatBE=t.Float=t.NearInt64BE=t.NearInt64=t.NearUInt64BE=t.NearUInt64=t.IntBE=t.Int=t.UIntBE=t.UInt=t.OffsetLayout=t.GreedyCount=t.ExternalLayout=t.bindConstructorLayout=t.nameWithProperty=t.Layout=t.uint8ArrayToBuffer=t.checkUint8Array=void 0,t.constant=t.utf8=t.cstr=t.blob=t.unionLayoutDiscriminator=t.union=t.seq=t.bits=t.struct=t.f64be=t.f64=t.f32be=t.f32=t.ns64be=t.s48be=t.s40be=t.s32be=t.s24be=t.s16be=t.ns64=t.s48=t.s40=t.s32=t.s24=void 0;const n=r(901048);function checkUint8Array(e){if(!(e instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}function uint8ArrayToBuffer(e){return checkUint8Array(e),n.Buffer.from(e.buffer,e.byteOffset,e.length)}t.checkUint8Array=checkUint8Array,t.uint8ArrayToBuffer=uint8ArrayToBuffer;class Layout{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}function nameWithProperty(e,t){return t.property?e+"["+t.property+"]":e}t.Layout=Layout,t.nameWithProperty=nameWithProperty,t.bindConstructorLayout=function bindConstructorLayout(e,t){if("function"!=typeof e)throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(e,"layout_"))throw new Error("Class is already bound to a layout");if(!(t&&t instanceof Layout))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(t,"boundConstructor_"))throw new Error("layout is already bound to a constructor");e.layout_=t,t.boundConstructor_=e,t.makeDestinationObject=()=>new e,Object.defineProperty(e.prototype,"encode",{value(e,r){return t.encode(this,e,r)},writable:!0}),Object.defineProperty(e,"decode",{value:(e,r)=>t.decode(e,r),writable:!0})};class ExternalLayout extends Layout{isCount(){throw new Error("ExternalLayout is abstract")}}t.ExternalLayout=ExternalLayout;class GreedyCount extends ExternalLayout{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){checkUint8Array(e);const r=e.length-t;return Math.floor(r/this.elementSpan)}encode(e,t,r){return 0}}t.GreedyCount=GreedyCount;class OffsetLayout extends ExternalLayout{constructor(e,t=0,r){if(!(e instanceof Layout))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,r||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof UInt||this.layout instanceof UIntBE}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,r=0){return this.layout.encode(e,t,r+this.offset)}}t.OffsetLayout=OffsetLayout;class UInt extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readUIntLE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeUIntLE(e,r,this.span),this.span}}t.UInt=UInt;class UIntBE extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readUIntBE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeUIntBE(e,r,this.span),this.span}}t.UIntBE=UIntBE;class Int extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readIntLE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeIntLE(e,r,this.span),this.span}}t.Int=Int;class IntBE extends Layout{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return uint8ArrayToBuffer(e).readIntBE(t,this.span)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeIntBE(e,r,this.span),this.span}}t.IntBE=IntBE;const i=Math.pow(2,32);function divmodInt64(e){const t=Math.floor(e/i);return{hi32:t,lo32:e-t*i}}function roundedInt64(e,t){return e*i+t}class NearUInt64 extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e),n=r.readUInt32LE(t);return roundedInt64(r.readUInt32LE(t+4),n)}encode(e,t,r=0){const n=divmodInt64(e),i=uint8ArrayToBuffer(t);return i.writeUInt32LE(n.lo32,r),i.writeUInt32LE(n.hi32,r+4),8}}t.NearUInt64=NearUInt64;class NearUInt64BE extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e);return roundedInt64(r.readUInt32BE(t),r.readUInt32BE(t+4))}encode(e,t,r=0){const n=divmodInt64(e),i=uint8ArrayToBuffer(t);return i.writeUInt32BE(n.hi32,r),i.writeUInt32BE(n.lo32,r+4),8}}t.NearUInt64BE=NearUInt64BE;class NearInt64 extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e),n=r.readUInt32LE(t);return roundedInt64(r.readInt32LE(t+4),n)}encode(e,t,r=0){const n=divmodInt64(e),i=uint8ArrayToBuffer(t);return i.writeUInt32LE(n.lo32,r),i.writeInt32LE(n.hi32,r+4),8}}t.NearInt64=NearInt64;class NearInt64BE extends Layout{constructor(e){super(8,e)}decode(e,t=0){const r=uint8ArrayToBuffer(e);return roundedInt64(r.readInt32BE(t),r.readUInt32BE(t+4))}encode(e,t,r=0){const n=divmodInt64(e),i=uint8ArrayToBuffer(t);return i.writeInt32BE(n.hi32,r),i.writeUInt32BE(n.lo32,r+4),8}}t.NearInt64BE=NearInt64BE;class Float extends Layout{constructor(e){super(4,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readFloatLE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeFloatLE(e,r),4}}t.Float=Float;class FloatBE extends Layout{constructor(e){super(4,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readFloatBE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeFloatBE(e,r),4}}t.FloatBE=FloatBE;class Double extends Layout{constructor(e){super(8,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readDoubleLE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeDoubleLE(e,r),8}}t.Double=Double;class DoubleBE extends Layout{constructor(e){super(8,e)}decode(e,t=0){return uint8ArrayToBuffer(e).readDoubleBE(t)}encode(e,t,r=0){return uint8ArrayToBuffer(t).writeDoubleBE(e,r),8}}t.DoubleBE=DoubleBE;class Sequence extends Layout{constructor(e,t,r){if(!(e instanceof Layout))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof ExternalLayout&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let n=-1;!(t instanceof ExternalLayout)&&0<e.span&&(n=t*e.span),super(n,r),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0,n=this.count;if(n instanceof ExternalLayout&&(n=n.decode(e,t)),0<this.elementLayout.span)r=n*this.elementLayout.span;else{let i=0;for(;i<n;)r+=this.elementLayout.getSpan(e,t+r),++i}return r}decode(e,t=0){const r=[];let n=0,i=this.count;for(i instanceof ExternalLayout&&(i=i.decode(e,t));n<i;)r.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),n+=1;return r}encode(e,t,r=0){const n=this.elementLayout,i=e.reduce(((e,i)=>e+n.encode(i,t,r+e)),0);return this.count instanceof ExternalLayout&&this.count.encode(e.length,t,r),i}}t.Sequence=Sequence;class Structure extends Layout{constructor(e,t,r){if(!Array.isArray(e)||!e.reduce(((e,t)=>e&&t instanceof Layout),!0))throw new TypeError("fields must be array of Layout instances");"boolean"==typeof t&&void 0===r&&(r=t,t=void 0);for(const t of e)if(0>t.span&&void 0===t.property)throw new Error("fields cannot contain unnamed variable-length layout");let n=-1;try{n=e.reduce(((e,t)=>e+t.getSpan()),0)}catch(e){}super(n,t),this.fields=e,this.decodePrefixes=!!r}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;try{r=this.fields.reduce(((r,n)=>{const i=n.getSpan(e,t);return t+=i,r+i}),0)}catch(e){throw new RangeError("indeterminate span")}return r}decode(e,t=0){checkUint8Array(e);const r=this.makeDestinationObject();for(const n of this.fields)if(void 0!==n.property&&(r[n.property]=n.decode(e,t)),t+=n.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return r}encode(e,t,r=0){const n=r;let i=0,s=0;for(const n of this.fields){let o=n.span;if(s=0<o?o:0,void 0!==n.property){const i=e[n.property];void 0!==i&&(s=n.encode(i,t,r),0>o&&(o=n.getSpan(t,r)))}i=r,r+=o}return i+s-n}fromArray(e){const t=this.makeDestinationObject();for(const r of this.fields)void 0!==r.property&&0<e.length&&(t[r.property]=e.shift());return t}layoutFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if("string"!=typeof e)throw new TypeError("property must be string");let t=0;for(const r of this.fields){if(r.property===e)return t;0>r.span?t=-1:0<=t&&(t+=r.span)}}}t.Structure=Structure;class UnionDiscriminator{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,r){throw new Error("UnionDiscriminator is abstract")}}t.UnionDiscriminator=UnionDiscriminator;class UnionLayoutDiscriminator extends UnionDiscriminator{constructor(e,t){if(!(e instanceof ExternalLayout&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,r){return this.layout.encode(e,t,r)}}t.UnionLayoutDiscriminator=UnionLayoutDiscriminator;class Union extends Layout{constructor(e,t,r){let n;if(e instanceof UInt||e instanceof UIntBE)n=new UnionLayoutDiscriminator(new OffsetLayout(e));else if(e instanceof ExternalLayout&&e.isCount())n=new UnionLayoutDiscriminator(e);else{if(!(e instanceof UnionDiscriminator))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");n=e}if(void 0===t&&(t=null),!(null===t||t instanceof Layout))throw new TypeError("defaultLayout must be null or a Layout");if(null!==t){if(0>t.span)throw new Error("defaultLayout must have constant span");void 0===t.property&&(t=t.replicate("content"))}let i=-1;t&&(i=t.span,0<=i&&(e instanceof UInt||e instanceof UIntBE)&&(i+=n.layout.span)),super(i,r),this.discriminator=n,this.usesPrefixDiscriminator=e instanceof UInt||e instanceof UIntBE,this.defaultLayout=t,this.registry={};let s=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(e){return s(e)},this.configGetSourceVariant=function(e){s=e.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const r=this.getVariant(e,t);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const r=this.registry[t];if(r.property&&Object.prototype.hasOwnProperty.call(e,r.property))return r}throw new Error("unable to infer src variant")}decode(e,t=0){let r;const n=this.discriminator,i=n.decode(e,t),s=this.registry[i];if(void 0===s){const s=this.defaultLayout;let o=0;this.usesPrefixDiscriminator&&(o=n.layout.span),r=this.makeDestinationObject(),r[n.property]=i,r[s.property]=s.decode(e,t+o)}else r=s.decode(e,t);return r}encode(e,t,r=0){const n=this.getSourceVariant(e);if(void 0===n){const n=this.discriminator,i=this.defaultLayout;let s=0;return this.usesPrefixDiscriminator&&(s=n.layout.span),n.encode(e[n.property],t,r),s+i.encode(e[i.property],t,r+s)}return n.encode(e,t,r)}addVariant(e,t,r){const n=new VariantLayout(this,e,t,r);return this.registry[e]=n,n}getVariant(e,t=0){let r;return r=e instanceof Uint8Array?this.discriminator.decode(e,t):e,this.registry[r]}}t.Union=Union;class VariantLayout extends Layout{constructor(e,t,r,n){if(!(e instanceof Union))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if("string"==typeof r&&void 0===n&&(n=r,r=null),r){if(!(r instanceof Layout))throw new TypeError("layout must be a Layout");if(null!==e.defaultLayout&&0<=r.span&&r.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if("string"!=typeof n)throw new TypeError("variant must have a String property")}let i=e.span;0>e.span&&(i=r?r.span:0,0<=i&&e.usesPrefixDiscriminator&&(i+=e.discriminator.layout.span)),super(i,n),this.union=e,this.variant=t,this.layout=r||null}getSpan(e,t=0){if(0<=this.span)return this.span;let r=0;this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span);let n=0;return this.layout&&(n=this.layout.getSpan(e,t+r)),r+n}decode(e,t=0){const r=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let n=0;return this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(e,t+n):this.property?r[this.property]=!0:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(e,t,r=0){let n=0;if(this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,r);let i=n;if(this.layout&&(this.layout.encode(e[this.property],t,r+n),i+=this.layout.getSpan(t,r+n),0<=this.union.span&&i>this.union.span))throw new Error("encoded variant overruns containing union");return i}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}function fixBitwiseResult(e){return 0>e&&(e+=4294967296),e}t.VariantLayout=VariantLayout;class BitStructure extends Layout{constructor(e,t,r){if(!(e instanceof UInt||e instanceof UIntBE))throw new TypeError("word must be a UInt or UIntBE layout");if("string"==typeof t&&void 0===r&&(r=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,r),this.word=e,this.msb=!!t,this.fields=[];let n=0;this._packedSetValue=function(e){return n=fixBitwiseResult(e),this},this._packedGetValue=function(){return n}}decode(e,t=0){const r=this.makeDestinationObject(),n=this.word.decode(e,t);this._packedSetValue(n);for(const t of this.fields)void 0!==t.property&&(r[t.property]=t.decode(e));return r}encode(e,t,r=0){const n=this.word.decode(t,r);this._packedSetValue(n);for(const t of this.fields)if(void 0!==t.property){const r=e[t.property];void 0!==r&&t.encode(r)}return this.word.encode(this._packedGetValue(),t,r)}addField(e,t){const r=new BitField(this,e,t);return this.fields.push(r),r}addBoolean(e){const t=new Boolean(this,e);return this.fields.push(t),t}fieldFor(e){if("string"!=typeof e)throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}t.BitStructure=BitStructure;class BitField{constructor(e,t,r){if(!(e instanceof BitStructure))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const n=8*e.span,i=e.fields.reduce(((e,t)=>e+t.bits),0);if(t+i>n)throw new Error("bits too long for span remainder ("+(n-i)+" of "+n+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,32===t&&(this.valueMask=4294967295),this.start=i,this.container.msb&&(this.start=n-i-t),this.wordMask=fixBitwiseResult(this.valueMask<<this.start),this.property=r}decode(e,t){return fixBitwiseResult(this.container._packedGetValue()&this.wordMask)>>>this.start}encode(e){if("number"!=typeof e||!Number.isInteger(e)||e!==fixBitwiseResult(e&this.valueMask))throw new TypeError(nameWithProperty("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),r=fixBitwiseResult(e<<this.start);this.container._packedSetValue(fixBitwiseResult(t&~this.wordMask)|r)}}t.BitField=BitField;class Boolean extends BitField{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){"boolean"==typeof e&&(e=+e),super.encode(e)}}t.Boolean=Boolean;class Blob extends Layout{constructor(e,t){if(!(e instanceof ExternalLayout&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;e instanceof ExternalLayout||(r=e),super(r,t),this.length=e}getSpan(e,t){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),r}decode(e,t=0){let r=this.span;return 0>r&&(r=this.length.decode(e,t)),uint8ArrayToBuffer(e).slice(t,t+r)}encode(e,t,r){let n=this.length;if(this.length instanceof ExternalLayout&&(n=e.length),!(e instanceof Uint8Array&&n===e.length))throw new TypeError(nameWithProperty("Blob.encode",this)+" requires (length "+n+") Uint8Array as src");if(r+n>t.length)throw new RangeError("encoding overruns Uint8Array");const i=uint8ArrayToBuffer(e);return uint8ArrayToBuffer(t).write(i.toString("hex"),r,n,"hex"),this.length instanceof ExternalLayout&&this.length.encode(n,t,r),n}}t.Blob=Blob;class CString extends Layout{constructor(e){super(-1,e)}getSpan(e,t=0){checkUint8Array(e);let r=t;for(;r<e.length&&0!==e[r];)r+=1;return 1+r-t}decode(e,t=0){const r=this.getSpan(e,t);return uint8ArrayToBuffer(e).slice(t,t+r-1).toString("utf-8")}encode(e,t,r=0){"string"!=typeof e&&(e=String(e));const i=n.Buffer.from(e,"utf8"),s=i.length;if(r+s>t.length)throw new RangeError("encoding overruns Buffer");const o=uint8ArrayToBuffer(t);return i.copy(o,r),o[r+s]=0,s+1}}t.CString=CString;class UTF8 extends Layout{constructor(e,t){if("string"==typeof e&&void 0===t&&(t=e,e=void 0),void 0===e)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return checkUint8Array(e),e.length-t}decode(e,t=0){const r=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<r)throw new RangeError("text length exceeds maxSpan");return uint8ArrayToBuffer(e).slice(t,t+r).toString("utf-8")}encode(e,t,r=0){"string"!=typeof e&&(e=String(e));const i=n.Buffer.from(e,"utf8"),s=i.length;if(0<=this.maxSpan&&this.maxSpan<s)throw new RangeError("text length exceeds maxSpan");if(r+s>t.length)throw new RangeError("encoding overruns Buffer");return i.copy(uint8ArrayToBuffer(t),r),s}}t.UTF8=UTF8;class Constant extends Layout{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,r){return 0}}t.Constant=Constant,t.greedy=(e,t)=>new GreedyCount(e,t),t.offset=(e,t,r)=>new OffsetLayout(e,t,r),t.u8=e=>new UInt(1,e),t.u16=e=>new UInt(2,e),t.u24=e=>new UInt(3,e),t.u32=e=>new UInt(4,e),t.u40=e=>new UInt(5,e),t.u48=e=>new UInt(6,e),t.nu64=e=>new NearUInt64(e),t.u16be=e=>new UIntBE(2,e),t.u24be=e=>new UIntBE(3,e),t.u32be=e=>new UIntBE(4,e),t.u40be=e=>new UIntBE(5,e),t.u48be=e=>new UIntBE(6,e),t.nu64be=e=>new NearUInt64BE(e),t.s8=e=>new Int(1,e),t.s16=e=>new Int(2,e),t.s24=e=>new Int(3,e),t.s32=e=>new Int(4,e),t.s40=e=>new Int(5,e),t.s48=e=>new Int(6,e),t.ns64=e=>new NearInt64(e),t.s16be=e=>new IntBE(2,e),t.s24be=e=>new IntBE(3,e),t.s32be=e=>new IntBE(4,e),t.s40be=e=>new IntBE(5,e),t.s48be=e=>new IntBE(6,e),t.ns64be=e=>new NearInt64BE(e),t.f32=e=>new Float(e),t.f32be=e=>new FloatBE(e),t.f64=e=>new Double(e),t.f64be=e=>new DoubleBE(e),t.struct=(e,t,r)=>new Structure(e,t,r),t.bits=(e,t,r)=>new BitStructure(e,t,r),t.seq=(e,t,r)=>new Sequence(e,t,r),t.union=(e,t,r)=>new Union(e,t,r),t.unionLayoutDiscriminator=(e,t)=>new UnionLayoutDiscriminator(e,t),t.blob=(e,t)=>new Blob(e,t),t.cstr=e=>new CString(e),t.utf8=(e,t)=>new UTF8(e,t),t.constant=(e,t)=>new Constant(e,t)},398532:(e,t,r)=>{"use strict";r.d(t,{kc:()=>AddressLookupTableAccount,$v:()=>ComputeBudgetInstruction,d_:()=>ComputeBudgetProgram,mj:()=>Ae,J3:()=>PublicKey,Ur:()=>We,Sq:()=>SystemInstruction,yq:()=>SystemProgram,ZX:()=>Transaction,fH:()=>TransactionInstruction,wu:()=>TransactionMessage,Kt:()=>VersionedTransaction});var n={};r.r(n),r.d(n,{DO:()=>utils_abytes,OG:()=>bitMask,My:()=>abstract_utils_bytesToHex,bytesToNumberBE:()=>utils_bytesToNumberBE,lX:()=>utils_bytesToNumberLE,Id:()=>abstract_utils_concatBytes,fg:()=>createHmacDrbg,qj:()=>utils_ensureBytes,hexToBytes:()=>utils_hexToBytes,aY:()=>abstract_utils_isBytes,lq:()=>utils_numberToBytesBE,z:()=>utils_numberToBytesLE,Q5:()=>validateObject});var i=r(901048);function _assert_number(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function bytes(e,...t){if(!function isBytes(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function _assert_hash(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");_assert_number(e.outputLen),_assert_number(e.blockLen)}function exists(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function output(e,t){bytes(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}const s="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;const createView=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),rotr=(e,t)=>e<<32-t|e>>>t;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function utils_utf8ToBytes(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}function toBytes(e){return"string"==typeof e&&(e=utils_utf8ToBytes(e)),bytes(e),e}function utils_concatBytes(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];bytes(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const i=e[t];r.set(i,n),n+=i.length}return r}class Hash{clone(){return this._cloneInto()}}function utils_wrapConstructor(e){const hashC=t=>e().update(toBytes(t)).digest(),t=e();return hashC.outputLen=t.outputLen,hashC.blockLen=t.blockLen,hashC.create=()=>e(),hashC}function utils_randomBytes(e=32){if(s&&"function"==typeof s.getRandomValues)return s.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}const Maj=(e,t,r)=>e&t^e&r^t&r;class HashMD extends Hash{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView(this.buffer)}update(e){exists(this);const{view:t,buffer:r,blockLen:n}=this,i=(e=toBytes(e)).length;for(let s=0;s<i;){const o=Math.min(n-this.pos,i-s);if(o!==n)r.set(e.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===n&&(this.process(t,0),this.pos=0);else{const t=createView(e);for(;n<=i-s;s+=n)this.process(t,s)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){exists(this),output(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:i}=this;let{pos:s}=this;t[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>n-s&&(this.process(r,0),s=0);for(let e=s;e<n;e++)t[e]=0;!function setBigUint64(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const i=BigInt(32),s=BigInt(4294967295),o=Number(r>>i&s),a=Number(r&s),u=n?4:0,c=n?0:4;e.setUint32(t+u,o,n),e.setUint32(t+c,a,n)}(r,n-8,BigInt(8*this.length),i),this.process(r,0);const o=createView(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=a/4,c=this.get();if(u>c.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<u;e++)o.setUint32(4*e,c[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:i,destroyed:s,pos:o}=this;return e.length=n,e.pos=o,e.finished=i,e.destroyed=s,n%t&&e.buffer.set(r),e}}const o=BigInt(2**32-1),a=BigInt(32);function fromBig(e,t=!1){return t?{h:Number(e&o),l:Number(e>>a&o)}:{h:0|Number(e>>a&o),l:0|Number(e&o)}}const u={fromBig,split:function split(e,t=!1){let r=new Uint32Array(e.length),n=new Uint32Array(e.length);for(let i=0;i<e.length;i++){const{h:s,l:o}=fromBig(e[i],t);[r[i],n[i]]=[s,o]}return[r,n]},toBig:(e,t)=>BigInt(e>>>0)<<a|BigInt(t>>>0),shrSH:(e,t,r)=>e>>>r,shrSL:(e,t,r)=>e<<32-r|t>>>r,rotrSH:(e,t,r)=>e>>>r|t<<32-r,rotrSL:(e,t,r)=>e<<32-r|t>>>r,rotrBH:(e,t,r)=>e<<64-r|t>>>r-32,rotrBL:(e,t,r)=>e>>>r-32|t<<64-r,rotr32H:(e,t)=>t,rotr32L:(e,t)=>e,rotlSH:(e,t,r)=>e<<r|t>>>32-r,rotlSL:(e,t,r)=>t<<r|e>>>32-r,rotlBH:(e,t,r)=>t<<r-32|e>>>64-r,rotlBL:(e,t,r)=>e<<r-32|t>>>64-r,add:function add(e,t,r,n){const i=(t>>>0)+(n>>>0);return{h:e+r+(i/2**32|0)|0,l:0|i}},add3L:(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),add3H:(e,t,r,n)=>t+r+n+(e/2**32|0)|0,add4L:(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),add4H:(e,t,r,n,i)=>t+r+n+i+(e/2**32|0)|0,add5H:(e,t,r,n,i,s)=>t+r+n+i+s+(e/2**32|0)|0,add5L:(e,t,r,n,i)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(i>>>0)},[c,d]=(()=>u.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((e=>BigInt(e)))))(),l=new Uint32Array(80),f=new Uint32Array(80);class SHA512 extends HashMD{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:n,Ch:i,Cl:s,Dh:o,Dl:a,Eh:u,El:c,Fh:d,Fl:l,Gh:f,Gl:y,Hh:p,Hl:g}=this;return[e,t,r,n,i,s,o,a,u,c,d,l,f,y,p,g]}set(e,t,r,n,i,s,o,a,u,c,d,l,f,y,p,g){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|n,this.Ch=0|i,this.Cl=0|s,this.Dh=0|o,this.Dl=0|a,this.Eh=0|u,this.El=0|c,this.Fh=0|d,this.Fl=0|l,this.Gh=0|f,this.Gl=0|y,this.Hh=0|p,this.Hl=0|g}process(e,t){for(let r=0;r<16;r++,t+=4)l[r]=e.getUint32(t),f[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|l[e-15],r=0|f[e-15],n=u.rotrSH(t,r,1)^u.rotrSH(t,r,8)^u.shrSH(t,r,7),i=u.rotrSL(t,r,1)^u.rotrSL(t,r,8)^u.shrSL(t,r,7),s=0|l[e-2],o=0|f[e-2],a=u.rotrSH(s,o,19)^u.rotrBH(s,o,61)^u.shrSH(s,o,6),c=u.rotrSL(s,o,19)^u.rotrBL(s,o,61)^u.shrSL(s,o,6),d=u.add4L(i,c,f[e-7],f[e-16]),y=u.add4H(d,n,a,l[e-7],l[e-16]);l[e]=0|y,f[e]=0|d}let{Ah:r,Al:n,Bh:i,Bl:s,Ch:o,Cl:a,Dh:y,Dl:p,Eh:g,El:m,Fh:b,Fl:w,Gh:k,Gl:I,Hh:S,Hl:B}=this;for(let e=0;e<80;e++){const t=u.rotrSH(g,m,14)^u.rotrSH(g,m,18)^u.rotrBH(g,m,41),x=u.rotrSL(g,m,14)^u.rotrSL(g,m,18)^u.rotrBL(g,m,41),v=g&b^~g&k,E=m&w^~m&I,P=u.add5L(B,x,E,d[e],f[e]),A=u.add5H(P,S,t,v,c[e],l[e]),_=0|P,L=u.rotrSH(r,n,28)^u.rotrBH(r,n,34)^u.rotrBH(r,n,39),T=u.rotrSL(r,n,28)^u.rotrBL(r,n,34)^u.rotrBL(r,n,39),N=r&i^r&o^i&o,W=n&s^n&a^s&a;S=0|k,B=0|I,k=0|b,I=0|w,b=0|g,w=0|m,({h:g,l:m}=u.add(0|y,0|p,0|A,0|_)),y=0|o,p=0|a,o=0|i,a=0|s,i=0|r,s=0|n;const K=u.add3L(_,T,W);r=u.add3H(K,A,L,N),n=0|K}({h:r,l:n}=u.add(0|this.Ah,0|this.Al,0|r,0|n)),({h:i,l:s}=u.add(0|this.Bh,0|this.Bl,0|i,0|s)),({h:o,l:a}=u.add(0|this.Ch,0|this.Cl,0|o,0|a)),({h:y,l:p}=u.add(0|this.Dh,0|this.Dl,0|y,0|p)),({h:g,l:m}=u.add(0|this.Eh,0|this.El,0|g,0|m)),({h:b,l:w}=u.add(0|this.Fh,0|this.Fl,0|b,0|w)),({h:k,l:I}=u.add(0|this.Gh,0|this.Gl,0|k,0|I)),({h:S,l:B}=u.add(0|this.Hh,0|this.Hl,0|S,0|B)),this.set(r,n,i,s,o,a,y,p,g,m,b,w,k,I,S,B)}roundClean(){l.fill(0),f.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const y=utils_wrapConstructor((()=>new SHA512)),p=(BigInt(0),BigInt(1)),g=BigInt(2);function abstract_utils_isBytes(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}function utils_abytes(e){if(!abstract_utils_isBytes(e))throw new Error("Uint8Array expected")}const m=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function abstract_utils_bytesToHex(e){utils_abytes(e);let t="";for(let r=0;r<e.length;r++)t+=m[e[r]];return t}function hexToNumber(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}const b={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function utils_asciiToBase16(e){return e>=b._0&&e<=b._9?e-b._0:e>=b._A&&e<=b._F?e-(b._A-10):e>=b._a&&e<=b._f?e-(b._a-10):void 0}function utils_hexToBytes(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,r=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(r);for(let t=0,i=0;t<r;t++,i+=2){const r=utils_asciiToBase16(e.charCodeAt(i)),s=utils_asciiToBase16(e.charCodeAt(i+1));if(void 0===r||void 0===s){const t=e[i]+e[i+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+i)}n[t]=16*r+s}return n}function utils_bytesToNumberBE(e){return hexToNumber(abstract_utils_bytesToHex(e))}function utils_bytesToNumberLE(e){return utils_abytes(e),hexToNumber(abstract_utils_bytesToHex(Uint8Array.from(e).reverse()))}function utils_numberToBytesBE(e,t){return utils_hexToBytes(e.toString(16).padStart(2*t,"0"))}function utils_numberToBytesLE(e,t){return utils_numberToBytesBE(e,t).reverse()}function utils_ensureBytes(e,t,r){let n;if("string"==typeof t)try{n=utils_hexToBytes(t)}catch(r){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${r}`)}else{if(!abstract_utils_isBytes(t))throw new Error(`${e} must be hex string or Uint8Array`);n=Uint8Array.from(t)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(`${e} expected ${r} bytes, got ${i}`);return n}function abstract_utils_concatBytes(...e){let t=0;for(let r=0;r<e.length;r++){const n=e[r];utils_abytes(n),t+=n.length}const r=new Uint8Array(t);for(let t=0,n=0;t<e.length;t++){const i=e[t];r.set(i,n),n+=i.length}return r}const bitMask=e=>(g<<BigInt(e-1))-p,u8n=e=>new Uint8Array(e),u8fr=e=>Uint8Array.from(e);function createHmacDrbg(e,t,r){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=u8n(e),i=u8n(e),s=0;const reset=()=>{n.fill(1),i.fill(0),s=0},h=(...e)=>r(i,n,...e),reseed=(e=u8n())=>{i=h(u8fr([0]),e),n=h(),0!==e.length&&(i=h(u8fr([1]),e),n=h())},gen=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){n=h();const t=n.slice();r.push(t),e+=n.length}return abstract_utils_concatBytes(...r)};return(e,t)=>{let r;for(reset(),reseed(e);!(r=t(gen()));)reseed();return reset(),r}}const w={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||abstract_utils_isBytes(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function validateObject(e,t,r={}){const checkField=(t,r,n)=>{const i=w[r];if("function"!=typeof i)throw new Error(`Invalid validator "${r}", expected function`);const s=e[t];if(!(n&&void 0===s||i(s,e)))throw new Error(`Invalid param ${String(t)}=${s} (${typeof s}), expected ${r}`)};for(const[e,r]of Object.entries(t))checkField(e,r,!1);for(const[e,t]of Object.entries(r))checkField(e,t,!0);return e}const k=BigInt(0),I=BigInt(1),S=BigInt(2),B=BigInt(3),x=BigInt(4),v=BigInt(5),E=BigInt(8);BigInt(9),BigInt(16);function modular_mod(e,t){const r=e%t;return r>=k?r:t+r}function pow(e,t,r){if(r<=k||t<k)throw new Error("Expected power/modulo > 0");if(r===I)return k;let n=I;for(;t>k;)t&I&&(n=n*e%r),e=e*e%r,t>>=I;return n}function modular_pow2(e,t,r){let n=e;for(;t-- >k;)n*=n,n%=r;return n}function invert(e,t){if(e===k||t<=k)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=modular_mod(e,t),n=t,i=k,s=I,o=I,a=k;for(;r!==k;){const e=n/r,t=n%r,u=i-o*e,c=s-a*e;n=r,r=t,i=o,s=a,o=u,a=c}if(n!==I)throw new Error("invert: does not exist");return modular_mod(i,t)}function FpSqrt(e){if(e%x===B){const t=(e+I)/x;return function sqrt3mod4(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}if(e%E===v){const t=(e-v)/E;return function sqrt5mod8(e,r){const n=e.mul(r,S),i=e.pow(n,t),s=e.mul(r,i),o=e.mul(e.mul(s,S),i),a=e.mul(s,e.sub(o,e.ONE));if(!e.eql(e.sqr(a),r))throw new Error("Cannot find square root");return a}}return function tonelliShanks(e){const t=(e-I)/S;let r,n,i;for(r=e-I,n=0;r%S===k;r/=S,n++);for(i=S;i<e&&pow(i,t,e)!==e-I;i++);if(1===n){const t=(e+I)/x;return function tonelliFast(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}const s=(r+I)/S;return function tonelliSlow(e,o){if(e.pow(o,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let a=n,u=e.pow(e.mul(e.ONE,i),r),c=e.pow(o,s),d=e.pow(o,r);for(;!e.eql(d,e.ONE);){if(e.eql(d,e.ZERO))return e.ZERO;let t=1;for(let r=e.sqr(d);t<a&&!e.eql(r,e.ONE);t++)r=e.sqr(r);const r=e.pow(u,I<<BigInt(a-t-1));u=e.sqr(r),c=e.mul(c,r),d=e.mul(d,u),a=t}return c}}(e)}const modular_isNegativeLE=(e,t)=>(modular_mod(e,t)&I)===I,P=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function nLength(e,t){const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Field(e,t,r=!1,n={}){if(e<=k)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:i,nByteLength:s}=nLength(e,t);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const o=FpSqrt(e),a=Object.freeze({ORDER:e,BITS:i,BYTES:s,MASK:bitMask(i),ZERO:k,ONE:I,create:t=>modular_mod(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return k<=t&&t<e},is0:e=>e===k,isOdd:e=>(e&I)===I,neg:t=>modular_mod(-t,e),eql:(e,t)=>e===t,sqr:t=>modular_mod(t*t,e),add:(t,r)=>modular_mod(t+r,e),sub:(t,r)=>modular_mod(t-r,e),mul:(t,r)=>modular_mod(t*r,e),pow:(e,t)=>function FpPow(e,t,r){if(r<k)throw new Error("Expected power > 0");if(r===k)return e.ONE;if(r===I)return t;let n=e.ONE,i=t;for(;r>k;)r&I&&(n=e.mul(n,i)),i=e.sqr(i),r>>=I;return n}(a,e,t),div:(t,r)=>modular_mod(t*invert(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>invert(t,e),sqrt:n.sqrt||(e=>o(a,e)),invertBatch:e=>function FpInvertBatch(e,t){const r=new Array(t.length),n=t.reduce(((t,n,i)=>e.is0(n)?t:(r[i]=t,e.mul(t,n))),e.ONE),i=e.inv(n);return t.reduceRight(((t,n,i)=>e.is0(n)?t:(r[i]=e.mul(t,r[i]),e.mul(t,n))),i),r}(a,e),cmov:(e,t,r)=>r?t:e,toBytes:e=>r?utils_numberToBytesLE(e,s):utils_numberToBytesBE(e,s),fromBytes:e=>{if(e.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${e.length}`);return r?utils_bytesToNumberLE(e):utils_bytesToNumberBE(e)}});return Object.freeze(a)}function getFieldBytesLength(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function getMinHashLength(e){const t=getFieldBytesLength(e);return t+Math.ceil(t/2)}const A=BigInt(0),_=BigInt(1);function wNAF(e,t){const constTimeNegate=(e,t)=>{const r=t.negate();return e?r:t},opts=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate,unsafeLadder(t,r){let n=e.ZERO,i=t;for(;r>A;)r&_&&(n=n.add(i)),i=i.double(),r>>=_;return n},precomputeWindow(e,t){const{windows:r,windowSize:n}=opts(t),i=[];let s=e,o=s;for(let e=0;e<r;e++){o=s,i.push(o);for(let e=1;e<n;e++)o=o.add(s),i.push(o);s=o.double()}return i},wNAF(t,r,n){const{windows:i,windowSize:s}=opts(t);let o=e.ZERO,a=e.BASE;const u=BigInt(2**t-1),c=2**t,d=BigInt(t);for(let e=0;e<i;e++){const t=e*s;let i=Number(n&u);n>>=d,i>s&&(i-=c,n+=_);const l=t,f=t+Math.abs(i)-1,y=e%2!=0,p=i<0;0===i?a=a.add(constTimeNegate(y,r[l])):o=o.add(constTimeNegate(p,r[f]))}return{p:o,f:a}},wNAFCached(e,t,r,n){const i=e._WINDOW_SIZE||1;let s=t.get(e);return s||(s=this.precomputeWindow(e,i),1!==i&&t.set(e,n(s))),this.wNAF(i,s,r)}}}function validateBasic(e){return function validateField(e){return validateObject(e,P.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}(e.Fp),validateObject(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const L=BigInt(0),T=BigInt(1),N=BigInt(2),W=BigInt(8),K={zip215:!0};function twistedEdwards(e){const t=function validateOpts(e){const t=validateBasic(e);return validateObject(e,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}(e),{Fp:r,n,prehash:i,hash:s,randomBytes:o,nByteLength:a,h:u}=t,c=N<<BigInt(8*a)-T,d=r.create,l=t.uvRatio||((e,t)=>{try{return{isValid:!0,value:r.sqrt(e*r.inv(t))}}catch(e){return{isValid:!1,value:L}}}),f=t.adjustScalarBytes||(e=>e),y=t.domain||((e,t,r)=>{if(t.length||r)throw new Error("Contexts/pre-hash are not supported");return e}),inBig=e=>"bigint"==typeof e&&L<e,inRange=(e,t)=>inBig(e)&&inBig(t)&&e<t,in0MaskRange=e=>e===L||inRange(e,c);function assertInRange(e,t){if(inRange(e,t))return e;throw new Error(`Expected valid scalar < ${t}, got ${typeof e} ${e}`)}function assertGE0(e){return e===L?e:assertInRange(e,n)}const p=new Map;function isPoint(e){if(!(e instanceof Point))throw new Error("ExtendedPoint expected")}class Point{constructor(e,t,r,n){if(this.ex=e,this.ey=t,this.ez=r,this.et=n,!in0MaskRange(e))throw new Error("x required");if(!in0MaskRange(t))throw new Error("y required");if(!in0MaskRange(r))throw new Error("z required");if(!in0MaskRange(n))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(e){if(e instanceof Point)throw new Error("extended point not allowed");const{x:t,y:r}=e||{};if(!in0MaskRange(t)||!in0MaskRange(r))throw new Error("invalid affine point");return new Point(t,r,T,d(t*r))}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.ez)));return e.map(((e,r)=>e.toAffine(t[r]))).map(Point.fromAffine)}_setWindowSize(e){this._WINDOW_SIZE=e,p.delete(this)}assertValidity(){const{a:e,d:r}=t;if(this.is0())throw new Error("bad point: ZERO");const{ex:n,ey:i,ez:s,et:o}=this,a=d(n*n),u=d(i*i),c=d(s*s),l=d(c*c),f=d(a*e);if(d(c*d(f+u))!==d(l+d(r*d(a*u))))throw new Error("bad point: equation left != right (1)");if(d(n*i)!==d(s*o))throw new Error("bad point: equation left != right (2)")}equals(e){isPoint(e);const{ex:t,ey:r,ez:n}=this,{ex:i,ey:s,ez:o}=e,a=d(t*o),u=d(i*n),c=d(r*o),l=d(s*n);return a===u&&c===l}is0(){return this.equals(Point.ZERO)}negate(){return new Point(d(-this.ex),this.ey,this.ez,d(-this.et))}double(){const{a:e}=t,{ex:r,ey:n,ez:i}=this,s=d(r*r),o=d(n*n),a=d(N*d(i*i)),u=d(e*s),c=r+n,l=d(d(c*c)-s-o),f=u+o,y=f-a,p=u-o,g=d(l*y),m=d(f*p),b=d(l*p),w=d(y*f);return new Point(g,m,w,b)}add(e){isPoint(e);const{a:r,d:n}=t,{ex:i,ey:s,ez:o,et:a}=this,{ex:u,ey:c,ez:l,et:f}=e;if(r===BigInt(-1)){const e=d((s-i)*(c+u)),t=d((s+i)*(c-u)),r=d(t-e);if(r===L)return this.double();const n=d(o*N*f),y=d(a*N*l),p=y+n,g=t+e,m=y-n,b=d(p*r),w=d(g*m),k=d(p*m),I=d(r*g);return new Point(b,w,I,k)}const y=d(i*u),p=d(s*c),g=d(a*n*f),m=d(o*l),b=d((i+s)*(u+c)-y-p),w=m-g,k=m+g,I=d(p-r*y),S=d(b*w),B=d(k*I),x=d(b*I),v=d(w*k);return new Point(S,B,v,x)}subtract(e){return this.add(e.negate())}wNAF(e){return b.wNAFCached(this,p,e,Point.normalizeZ)}multiply(e){const{p:t,f:r}=this.wNAF(assertInRange(e,n));return Point.normalizeZ([t,r])[0]}multiplyUnsafe(e){let t=assertGE0(e);return t===L?m:this.equals(m)||t===T?this:this.equals(g)?this.wNAF(t).p:b.unsafeLadder(this,t)}isSmallOrder(){return this.multiplyUnsafe(u).is0()}isTorsionFree(){return b.unsafeLadder(this,n).is0()}toAffine(e){const{ex:t,ey:n,ez:i}=this,s=this.is0();null==e&&(e=s?W:r.inv(i));const o=d(t*e),a=d(n*e),u=d(i*e);if(s)return{x:L,y:T};if(u!==T)throw new Error("invZ was invalid");return{x:o,y:a}}clearCofactor(){const{h:e}=t;return e===T?this:this.multiplyUnsafe(e)}static fromHex(e,n=!1){const{d:i,a:s}=t,o=r.BYTES,a=(e=utils_ensureBytes("pointHex",e,o)).slice(),u=e[o-1];a[o-1]=-129&u;const f=utils_bytesToNumberLE(a);f===L||assertInRange(f,n?c:r.ORDER);const y=d(f*f),p=d(y-T),g=d(i*y-s);let{isValid:m,value:b}=l(p,g);if(!m)throw new Error("Point.fromHex: invalid y coordinate");const w=(b&T)===T,k=!!(128&u);if(!n&&b===L&&k)throw new Error("Point.fromHex: x=0 and x_0=1");return k!==w&&(b=d(-b)),Point.fromAffine({x:b,y:f})}static fromPrivateKey(e){return getExtendedPublicKey(e).point}toRawBytes(){const{x:e,y:t}=this.toAffine(),n=utils_numberToBytesLE(t,r.BYTES);return n[n.length-1]|=e&T?128:0,n}toHex(){return abstract_utils_bytesToHex(this.toRawBytes())}}Point.BASE=new Point(t.Gx,t.Gy,T,d(t.Gx*t.Gy)),Point.ZERO=new Point(L,T,T,L);const{BASE:g,ZERO:m}=Point,b=wNAF(Point,8*a);function modN(e){return modular_mod(e,n)}function modN_LE(e){return modN(utils_bytesToNumberLE(e))}function getExtendedPublicKey(e){const t=a;e=utils_ensureBytes("private key",e,t);const r=utils_ensureBytes("hashed private key",s(e),2*t),n=f(r.slice(0,t)),i=r.slice(t,2*t),o=modN_LE(n),u=g.multiply(o),c=u.toRawBytes();return{head:n,prefix:i,scalar:o,point:u,pointBytes:c}}function hashDomainToScalar(e=new Uint8Array,...t){const r=abstract_utils_concatBytes(...t);return modN_LE(s(y(r,utils_ensureBytes("context",e),!!i)))}const w=K;g._setWindowSize(8);return{CURVE:t,getPublicKey:function getPublicKey(e){return getExtendedPublicKey(e).pointBytes},sign:function sign(e,t,n={}){e=utils_ensureBytes("message",e),i&&(e=i(e));const{prefix:s,scalar:o,pointBytes:u}=getExtendedPublicKey(t),c=hashDomainToScalar(n.context,s,e),d=g.multiply(c).toRawBytes(),l=modN(c+hashDomainToScalar(n.context,d,u,e)*o);return assertGE0(l),utils_ensureBytes("result",abstract_utils_concatBytes(d,utils_numberToBytesLE(l,r.BYTES)),2*a)},verify:function verify(e,t,n,s=w){const{context:o,zip215:a}=s,u=r.BYTES;e=utils_ensureBytes("signature",e,2*u),t=utils_ensureBytes("message",t),i&&(t=i(t));const c=utils_bytesToNumberLE(e.slice(u,2*u));let d,l,f;try{d=Point.fromHex(n,a),l=Point.fromHex(e.slice(0,u),a),f=g.multiplyUnsafe(c)}catch(e){return!1}if(!a&&d.isSmallOrder())return!1;const y=hashDomainToScalar(o,l.toRawBytes(),d.toRawBytes(),t);return l.add(d.multiplyUnsafe(y)).subtract(f).clearCofactor().equals(Point.ZERO)},ExtendedPoint:Point,utils:{getExtendedPublicKey,randomPrivateKey:()=>o(r.BYTES),precompute:(e=8,t=Point.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)}}}const O=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),R=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),j=(BigInt(0),BigInt(1)),z=BigInt(2),C=BigInt(5),q=BigInt(10),U=BigInt(20),D=BigInt(40),Y=BigInt(80);function ed25519_pow_2_252_3(e){const t=O,r=e*e%t*e%t,n=modular_pow2(r,z,t)*r%t,i=modular_pow2(n,j,t)*e%t,s=modular_pow2(i,C,t)*i%t,o=modular_pow2(s,q,t)*s%t,a=modular_pow2(o,U,t)*o%t,u=modular_pow2(a,D,t)*a%t,c=modular_pow2(u,Y,t)*u%t,d=modular_pow2(c,Y,t)*u%t,l=modular_pow2(d,q,t)*s%t;return{pow_p_5_8:modular_pow2(l,z,t)*e%t,b2:r}}function adjustScalarBytes(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}function uvRatio(e,t){const r=O,n=modular_mod(t*t*t,r),i=modular_mod(n*n*t,r);let s=modular_mod(e*n*ed25519_pow_2_252_3(e*i).pow_p_5_8,r);const o=modular_mod(t*s*s,r),a=s,u=modular_mod(s*R,r),c=o===e,d=o===modular_mod(-e,r),l=o===modular_mod(-e*R,r);return c&&(s=a),(d||l)&&(s=u),modular_isNegativeLE(s,r)&&(s=modular_mod(-s,r)),{isValid:c||d,value:s}}const F=Field(O,void 0,!0),H={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:F,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:y,randomBytes:utils_randomBytes,adjustScalarBytes,uvRatio},M=twistedEdwards(H);function ed25519_domain(e,t,r){if(t.length>255)throw new Error("Context is too big");return utils_concatBytes(utils_utf8ToBytes("SigEd25519 no Ed25519 collisions"),new Uint8Array([r?1:0,t.length]),t,e)}const V=(F.ORDER+BigInt(3))/BigInt(8);F.pow(z,V),F.sqrt(F.neg(F.ONE)),F.ORDER,BigInt(5),BigInt(8),BigInt(486662);(function FpSqrtEven(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const r=e.sqrt(t);return e.isOdd(r)?e.neg(r):r})(F,F.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var $=r(682823),G=r.n($),Z=r(939216),J=r.n(Z),X=r(552001),Q=r(881818),ee=r(878918),te=r(856115),re=r(727801),ne=(r(759499),r(516246)),ie=(r(885364),r(52494));const se=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),oe=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ae=new Uint32Array(64);class SHA256 extends HashMD{constructor(){super(64,32,8,!1),this.A=0|oe[0],this.B=0|oe[1],this.C=0|oe[2],this.D=0|oe[3],this.E=0|oe[4],this.F=0|oe[5],this.G=0|oe[6],this.H=0|oe[7]}get(){const{A:e,B:t,C:r,D:n,E:i,F:s,G:o,H:a}=this;return[e,t,r,n,i,s,o,a]}set(e,t,r,n,i,s,o,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|s,this.G=0|o,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)ae[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=ae[e-15],r=ae[e-2],n=rotr(t,7)^rotr(t,18)^t>>>3,i=rotr(r,17)^rotr(r,19)^r>>>10;ae[e]=i+ae[e-7]+n+ae[e-16]|0}let{A:r,B:n,C:i,D:s,E:o,F:a,G:u,H:c}=this;for(let e=0;e<64;e++){const t=c+(rotr(o,6)^rotr(o,11)^rotr(o,25))+((d=o)&a^~d&u)+se[e]+ae[e]|0,l=(rotr(r,2)^rotr(r,13)^rotr(r,22))+Maj(r,n,i)|0;c=u,u=a,a=o,o=s+t|0,s=i,i=n,n=r,r=t+l|0}var d;r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,s=s+this.D|0,o=o+this.E|0,a=a+this.F|0,u=u+this.G|0,c=c+this.H|0,this.set(r,n,i,s,o,a,u,c)}roundClean(){ae.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const ue=utils_wrapConstructor((()=>new SHA256));class HMAC extends Hash{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,_assert_hash(e);const r=toBytes(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,i=new Uint8Array(n);i.set(r.length>n?e.create().update(r).digest():r);for(let e=0;e<i.length;e++)i[e]^=54;this.iHash.update(i),this.oHash=e.create();for(let e=0;e<i.length;e++)i[e]^=106;this.oHash.update(i),i.fill(0)}update(e){return exists(this),this.iHash.update(e),this}digestInto(e){exists(this),bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:n,destroyed:i,blockLen:s,outputLen:o}=this;return e.finished=n,e.destroyed=i,e.blockLen=s,e.outputLen=o,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(e,t,r)=>new HMAC(e,t).update(r).digest();hmac.create=(e,t)=>new HMAC(e,t);const{bytesToNumberBE:ce,hexToBytes:de}=n,le={Err:class DERErr extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:t}=le;if(e.length<2||2!==e[0])throw new t("Invalid signature integer tag");const r=e[1],n=e.subarray(2,r+2);if(!r||n.length!==r)throw new t("Invalid signature integer: wrong length");if(128&n[0])throw new t("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new t("Invalid signature integer: unnecessary leading zero");return{d:ce(n),l:e.subarray(r+2)}},toSig(e){const{Err:t}=le,r="string"==typeof e?de(e):e;utils_abytes(r);let n=r.length;if(n<2||48!=r[0])throw new t("Invalid signature tag");if(r[1]!==n-2)throw new t("Invalid signature: incorrect length");const{d:i,l:s}=le._parseInt(r.subarray(2)),{d:o,l:a}=le._parseInt(s);if(a.length)throw new t("Invalid signature: left bytes after parsing");return{r:i,s:o}},hexFromSig(e){const slice=e=>8&Number.parseInt(e[0],16)?"00"+e:e,h=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},t=slice(h(e.s)),r=slice(h(e.r)),n=t.length/2,i=r.length/2,s=h(n),o=h(i);return`30${h(i+n+4)}02${o}${r}02${s}${t}`}},he=BigInt(0),fe=BigInt(1),ye=(BigInt(2),BigInt(3));BigInt(4);function weierstrassPoints(e){const t=function validatePointOpts(e){const t=validateBasic(e);validateObject(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:i}=t;if(r){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:r}=t,n=t.toBytes||((e,t,n)=>{const i=t.toAffine();return abstract_utils_concatBytes(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),i=t.fromBytes||(e=>{const t=e.subarray(1);return{x:r.fromBytes(t.subarray(0,r.BYTES)),y:r.fromBytes(t.subarray(r.BYTES,2*r.BYTES))}});function weierstrassEquation(e){const{a:n,b:i}=t,s=r.sqr(e),o=r.mul(s,e);return r.add(r.add(o,r.mul(e,n)),i)}if(!r.eql(r.sqr(t.Gy),weierstrassEquation(t.Gx)))throw new Error("bad generator point: equation left != right");function isWithinCurveOrder(e){return"bigint"==typeof e&&he<e&&e<t.n}function assertGE(e){if(!isWithinCurveOrder(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function normPrivateKeyToScalar(e){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:s}=t;if(r&&"bigint"!=typeof e){if(abstract_utils_isBytes(e)&&(e=abstract_utils_bytesToHex(e)),"string"!=typeof e||!r.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*n,"0")}let o;try{o="bigint"==typeof e?e:utils_bytesToNumberBE(utils_ensureBytes("private key",e,n))}catch(t){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof e}`)}return i&&(o=modular_mod(o,s)),assertGE(o),o}const s=new Map;function assertPrjPoint(e){if(!(e instanceof Point))throw new Error("ProjectivePoint expected")}class Point{constructor(e,t,n){if(this.px=e,this.py=t,this.pz=n,null==e||!r.isValid(e))throw new Error("x required");if(null==t||!r.isValid(t))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(e){const{x:t,y:n}=e||{};if(!e||!r.isValid(t)||!r.isValid(n))throw new Error("invalid affine point");if(e instanceof Point)throw new Error("projective point not allowed");const is0=e=>r.eql(e,r.ZERO);return is0(t)&&is0(n)?Point.ZERO:new Point(t,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(Point.fromAffine)}static fromHex(e){const t=Point.fromAffine(i(utils_ensureBytes("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return Point.BASE.multiply(normPrivateKeyToScalar(e))}_setWindowSize(e){this._WINDOW_SIZE=e,s.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:n}=this.toAffine();if(!r.isValid(e)||!r.isValid(n))throw new Error("bad point: x or y not FE");const i=r.sqr(n),s=weierstrassEquation(e);if(!r.eql(i,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(r.isOdd)return!r.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){assertPrjPoint(e);const{px:t,py:n,pz:i}=this,{px:s,py:o,pz:a}=e,u=r.eql(r.mul(t,a),r.mul(s,i)),c=r.eql(r.mul(n,a),r.mul(o,i));return u&&c}negate(){return new Point(this.px,r.neg(this.py),this.pz)}double(){const{a:e,b:n}=t,i=r.mul(n,ye),{px:s,py:o,pz:a}=this;let u=r.ZERO,c=r.ZERO,d=r.ZERO,l=r.mul(s,s),f=r.mul(o,o),y=r.mul(a,a),p=r.mul(s,o);return p=r.add(p,p),d=r.mul(s,a),d=r.add(d,d),u=r.mul(e,d),c=r.mul(i,y),c=r.add(u,c),u=r.sub(f,c),c=r.add(f,c),c=r.mul(u,c),u=r.mul(p,u),d=r.mul(i,d),y=r.mul(e,y),p=r.sub(l,y),p=r.mul(e,p),p=r.add(p,d),d=r.add(l,l),l=r.add(d,l),l=r.add(l,y),l=r.mul(l,p),c=r.add(c,l),y=r.mul(o,a),y=r.add(y,y),l=r.mul(y,p),u=r.sub(u,l),d=r.mul(y,f),d=r.add(d,d),d=r.add(d,d),new Point(u,c,d)}add(e){assertPrjPoint(e);const{px:n,py:i,pz:s}=this,{px:o,py:a,pz:u}=e;let c=r.ZERO,d=r.ZERO,l=r.ZERO;const f=t.a,y=r.mul(t.b,ye);let p=r.mul(n,o),g=r.mul(i,a),m=r.mul(s,u),b=r.add(n,i),w=r.add(o,a);b=r.mul(b,w),w=r.add(p,g),b=r.sub(b,w),w=r.add(n,s);let k=r.add(o,u);return w=r.mul(w,k),k=r.add(p,m),w=r.sub(w,k),k=r.add(i,s),c=r.add(a,u),k=r.mul(k,c),c=r.add(g,m),k=r.sub(k,c),l=r.mul(f,w),c=r.mul(y,m),l=r.add(c,l),c=r.sub(g,l),l=r.add(g,l),d=r.mul(c,l),g=r.add(p,p),g=r.add(g,p),m=r.mul(f,m),w=r.mul(y,w),g=r.add(g,m),m=r.sub(p,m),m=r.mul(f,m),w=r.add(w,m),p=r.mul(g,w),d=r.add(d,p),p=r.mul(k,w),c=r.mul(b,c),c=r.sub(c,p),p=r.mul(b,g),l=r.mul(k,l),l=r.add(l,p),new Point(c,d,l)}subtract(e){return this.add(e.negate())}is0(){return this.equals(Point.ZERO)}wNAF(e){return a.wNAFCached(this,s,e,(e=>{const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(Point.fromAffine)}))}multiplyUnsafe(e){const n=Point.ZERO;if(e===he)return n;if(assertGE(e),e===fe)return this;const{endo:i}=t;if(!i)return a.unsafeLadder(this,e);let{k1neg:s,k1:o,k2neg:u,k2:c}=i.splitScalar(e),d=n,l=n,f=this;for(;o>he||c>he;)o&fe&&(d=d.add(f)),c&fe&&(l=l.add(f)),f=f.double(),o>>=fe,c>>=fe;return s&&(d=d.negate()),u&&(l=l.negate()),l=new Point(r.mul(l.px,i.beta),l.py,l.pz),d.add(l)}multiply(e){assertGE(e);let n,i,s=e;const{endo:o}=t;if(o){const{k1neg:e,k1:t,k2neg:u,k2:c}=o.splitScalar(s);let{p:d,f:l}=this.wNAF(t),{p:f,f:y}=this.wNAF(c);d=a.constTimeNegate(e,d),f=a.constTimeNegate(u,f),f=new Point(r.mul(f.px,o.beta),f.py,f.pz),n=d.add(f),i=l.add(y)}else{const{p:e,f:t}=this.wNAF(s);n=e,i=t}return Point.normalizeZ([n,i])[0]}multiplyAndAddUnsafe(e,t,r){const n=Point.BASE,mul=(e,t)=>t!==he&&t!==fe&&e.equals(n)?e.multiply(t):e.multiplyUnsafe(t),i=mul(this,t).add(mul(e,r));return i.is0()?void 0:i}toAffine(e){const{px:t,py:n,pz:i}=this,s=this.is0();null==e&&(e=s?r.ONE:r.inv(i));const o=r.mul(t,e),a=r.mul(n,e),u=r.mul(i,e);if(s)return{x:r.ZERO,y:r.ZERO};if(!r.eql(u,r.ONE))throw new Error("invZ was invalid");return{x:o,y:a}}isTorsionFree(){const{h:e,isTorsionFree:r}=t;if(e===fe)return!0;if(r)return r(Point,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:r}=t;return e===fe?this:r?r(Point,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return this.assertValidity(),n(Point,this,e)}toHex(e=!0){return abstract_utils_bytesToHex(this.toRawBytes(e))}}Point.BASE=new Point(t.Gx,t.Gy,r.ONE),Point.ZERO=new Point(r.ZERO,r.ONE,r.ZERO);const o=t.nBitLength,a=wNAF(Point,t.endo?Math.ceil(o/2):o);return{CURVE:t,ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}}function weierstrass(e){const t=function weierstrass_validateOpts(e){const t=validateBasic(e);return validateObject(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:r,n}=t,i=r.BYTES+1,s=2*r.BYTES+1;function modN(e){return modular_mod(e,n)}function invN(e){return invert(e,n)}const{ProjectivePoint:o,normPrivateKeyToScalar:a,weierstrassEquation:u,isWithinCurveOrder:c}=weierstrassPoints({...t,toBytes(e,t,n){const i=t.toAffine(),s=r.toBytes(i.x),o=abstract_utils_concatBytes;return n?o(Uint8Array.from([t.hasEvenY()?2:3]),s):o(Uint8Array.from([4]),s,r.toBytes(i.y))},fromBytes(e){const t=e.length,n=e[0],o=e.subarray(1);if(t!==i||2!==n&&3!==n){if(t===s&&4===n){return{x:r.fromBytes(o.subarray(0,r.BYTES)),y:r.fromBytes(o.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${t} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`)}{const e=utils_bytesToNumberBE(o);if(!function isValidFieldElement(e){return he<e&&e<r.ORDER}(e))throw new Error("Point is not on curve");const t=u(e);let i;try{i=r.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("Point is not on curve"+t)}return!(1&~n)!==((i&fe)===fe)&&(i=r.neg(i)),{x:e,y:i}}}}),numToNByteStr=e=>abstract_utils_bytesToHex(utils_numberToBytesBE(e,t.nByteLength));function isBiggerThanHalfOrder(e){return e>n>>fe}const slcNum=(e,t,r)=>utils_bytesToNumberBE(e.slice(t,r));class Signature{constructor(e,t,r){this.r=e,this.s=t,this.recovery=r,this.assertValidity()}static fromCompact(e){const r=t.nByteLength;return e=utils_ensureBytes("compactSignature",e,2*r),new Signature(slcNum(e,0,r),slcNum(e,r,2*r))}static fromDER(e){const{r:t,s:r}=le.toSig(utils_ensureBytes("DER",e));return new Signature(t,r)}assertValidity(){if(!c(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!c(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new Signature(this.r,this.s,e)}recoverPublicKey(e){const{r:n,s:i,recovery:s}=this,a=f(utils_ensureBytes("msgHash",e));if(null==s||![0,1,2,3].includes(s))throw new Error("recovery id invalid");const u=2===s||3===s?n+t.n:n;if(u>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const c=1&s?"03":"02",d=o.fromHex(c+numToNByteStr(u)),l=invN(u),y=modN(-a*l),p=modN(i*l),g=o.BASE.multiplyAndAddUnsafe(d,y,p);if(!g)throw new Error("point at infinify");return g.assertValidity(),g}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return utils_hexToBytes(this.toDERHex())}toDERHex(){return le.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return utils_hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const d={isValidPrivateKey(e){try{return a(e),!0}catch(e){return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{const e=getMinHashLength(t.n);return function mapHashToField(e,t,r=!1){const n=e.length,i=getFieldBytesLength(t),s=getMinHashLength(t);if(n<16||n<s||n>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${n}`);const o=modular_mod(r?utils_bytesToNumberBE(e):utils_bytesToNumberLE(e),t-I)+I;return r?utils_numberToBytesLE(o,i):utils_numberToBytesBE(o,i)}(t.randomBytes(e),t.n)},precompute:(e=8,t=o.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function isProbPub(e){const t=abstract_utils_isBytes(e),r="string"==typeof e,n=(t||r)&&e.length;return t?n===i||n===s:r?n===2*i||n===2*s:e instanceof o}const l=t.bits2int||function(e){const r=utils_bytesToNumberBE(e),n=8*e.length-t.nBitLength;return n>0?r>>BigInt(n):r},f=t.bits2int_modN||function(e){return modN(l(e))},y=bitMask(t.nBitLength);function int2octets(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(he<=e&&e<y))throw new Error(`bigint expected < 2^${t.nBitLength}`);return utils_numberToBytesBE(e,t.nByteLength)}function prepSig(e,n,i=p){if(["recovered","canonical"].some((e=>e in i)))throw new Error("sign() legacy options not supported");const{hash:s,randomBytes:u}=t;let{lowS:d,prehash:y,extraEntropy:g}=i;null==d&&(d=!0),e=utils_ensureBytes("msgHash",e),y&&(e=utils_ensureBytes("prehashed msgHash",s(e)));const m=f(e),b=a(n),w=[int2octets(b),int2octets(m)];if(null!=g&&!1!==g){const e=!0===g?u(r.BYTES):g;w.push(utils_ensureBytes("extraEntropy",e))}const k=abstract_utils_concatBytes(...w),I=m;return{seed:k,k2sig:function k2sig(e){const t=l(e);if(!c(t))return;const r=invN(t),n=o.BASE.multiply(t).toAffine(),i=modN(n.x);if(i===he)return;const s=modN(r*modN(I+i*b));if(s===he)return;let a=(n.x===i?0:2)|Number(n.y&fe),u=s;return d&&isBiggerThanHalfOrder(s)&&(u=function normalizeS(e){return isBiggerThanHalfOrder(e)?modN(-e):e}(s),a^=1),new Signature(i,u,a)}}}const p={lowS:t.lowS,prehash:!1},g={lowS:t.lowS,prehash:!1};return o.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function getPublicKey(e,t=!0){return o.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function getSharedSecret(e,t,r=!0){if(isProbPub(e))throw new Error("first arg must be private key");if(!isProbPub(t))throw new Error("second arg must be public key");return o.fromHex(t).multiply(a(e)).toRawBytes(r)},sign:function sign(e,r,n=p){const{seed:i,k2sig:s}=prepSig(e,r,n),o=t;return createHmacDrbg(o.hash.outputLen,o.nByteLength,o.hmac)(i,s)},verify:function verify(e,r,n,i=g){const s=e;if(r=utils_ensureBytes("msgHash",r),n=utils_ensureBytes("publicKey",n),"strict"in i)throw new Error("options.strict was renamed to lowS");const{lowS:a,prehash:u}=i;let c,d;try{if("string"==typeof s||abstract_utils_isBytes(s))try{c=Signature.fromDER(s)}catch(e){if(!(e instanceof le.Err))throw e;c=Signature.fromCompact(s)}else{if("object"!=typeof s||"bigint"!=typeof s.r||"bigint"!=typeof s.s)throw new Error("PARSE");{const{r:e,s:t}=s;c=new Signature(e,t)}}d=o.fromHex(n)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(a&&c.hasHighS())return!1;u&&(r=t.hash(r));const{r:l,s:y}=c,p=f(r),m=invN(y),b=modN(p*m),w=modN(l*m),k=o.BASE.multiplyAndAddUnsafe(d,b,w)?.toAffine();return!!k&&modN(k.x)===l},ProjectivePoint:o,Signature,utils:d}}function getHash(e){return{hash:e,hmac:(t,...r)=>hmac(e,t,utils_concatBytes(...r)),randomBytes:utils_randomBytes}}const pe=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ge=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),me=BigInt(1),be=BigInt(2),divNearest=(e,t)=>(e+t/be)/t;function sqrtMod(e){const t=pe,r=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),a=BigInt(44),u=BigInt(88),c=e*e*e%t,d=c*c*e%t,l=modular_pow2(d,r,t)*d%t,f=modular_pow2(l,r,t)*d%t,y=modular_pow2(f,be,t)*c%t,p=modular_pow2(y,i,t)*y%t,g=modular_pow2(p,s,t)*p%t,m=modular_pow2(g,a,t)*g%t,b=modular_pow2(m,u,t)*m%t,w=modular_pow2(b,a,t)*g%t,k=modular_pow2(w,r,t)*d%t,I=modular_pow2(k,o,t)*p%t,S=modular_pow2(I,n,t)*c%t,B=modular_pow2(S,be,t);if(!we.eql(we.sqr(B),e))throw new Error("Cannot find square root");return B}const we=Field(pe,void 0,void 0,{sqrt:sqrtMod}),ke=function createCurve(e,t){const create=t=>weierstrass({...e,...getHash(t)});return Object.freeze({...create(t),create})}({a:BigInt(0),b:BigInt(7),Fp:we,n:ge,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=ge,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-me*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,o=BigInt("0x100000000000000000000000000000000"),a=divNearest(s*e,t),u=divNearest(-n*e,t);let c=modular_mod(e-a*r-u*i,t),d=modular_mod(-a*n-u*s,t);const l=c>o,f=d>o;if(l&&(c=t-c),f&&(d=t-d),c>o||d>o)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:l,k1:c,k2neg:f,k2:d}}}},ue);BigInt(0);ke.ProjectivePoint;M.utils.randomPrivateKey;const generateKeypair=()=>{const e=M.utils.randomPrivateKey(),t=Ie(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),{publicKey:t,secretKey:r}},Ie=M.getPublicKey;function isOnCurve(e){try{return M.ExtendedPoint.fromHex(e),!0}catch{return!1}}const sign=(e,t)=>M.sign(e,t.slice(0,32)),Se=M.verify,toBuffer=e=>i.Buffer.isBuffer(e)?e:e instanceof Uint8Array?i.Buffer.from(e.buffer,e.byteOffset,e.byteLength):i.Buffer.from(e);class Struct{constructor(e){Object.assign(this,e)}encode(){return i.Buffer.from((0,Q.serialize)(Be,this))}static decode(e){return(0,Q.deserialize)(Be,this,e)}static decodeUnchecked(e){return(0,Q.deserializeUnchecked)(Be,this,e)}}const Be=new Map;var xe;let ve;const Ee=32;let Pe=1;ve=Symbol.toStringTag;class PublicKey extends Struct{constructor(e){if(super({}),this._bn=void 0,function isPublicKeyData(e){return void 0!==e._bn}(e))this._bn=e._bn;else{if("string"==typeof e){const t=J().decode(e);if(t.length!=Ee)throw new Error("Invalid public key input");this._bn=new(G())(t)}else this._bn=new(G())(e);if(this._bn.byteLength()>Ee)throw new Error("Invalid public key input")}}static unique(){const e=new PublicKey(Pe);return Pe+=1,new PublicKey(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return J().encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(i.Buffer);if(e.length===Ee)return e;const t=i.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[ve](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const n=i.Buffer.concat([e.toBuffer(),i.Buffer.from(t),r.toBuffer()]),s=(0,X.s)(n);return new PublicKey(s)}static createProgramAddressSync(e,t){let r=i.Buffer.alloc(0);e.forEach((function(e){if(e.length>32)throw new TypeError("Max seed length exceeded");r=i.Buffer.concat([r,toBuffer(e)])})),r=i.Buffer.concat([r,t.toBuffer(),i.Buffer.from("ProgramDerivedAddress")]);const n=(0,X.s)(r);if(isOnCurve(n))throw new Error("Invalid seeds, address must fall off the curve");return new PublicKey(n)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r,n=255;for(;0!=n;){try{const s=e.concat(i.Buffer.from([n]));r=this.createProgramAddressSync(s,t)}catch(e){if(e instanceof TypeError)throw e;n--;continue}return[r,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){return isOnCurve(new PublicKey(e).toBytes())}}xe=PublicKey,PublicKey.default=new xe("11111111111111111111111111111111"),Be.set(PublicKey,{kind:"struct",fields:[["_bn","u256"]]});new PublicKey("BPFLoader1111111111111111111111111111111111");const Ae=1232;class TransactionExpiredBlockheightExceededError extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class TransactionExpiredTimeoutError extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredTimeoutError.prototype,"name",{value:"TransactionExpiredTimeoutError"});class TransactionExpiredNonceInvalidError extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(TransactionExpiredNonceInvalidError.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class MessageAccountKeys{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const t=new Map;this.keySegments().flat().forEach(((e,r)=>{t.set(e.toBase58(),r)}));const findKeyIndex=e=>{const r=t.get(e.toBase58());if(void 0===r)throw new Error("Encountered an unknown instruction account key during compilation");return r};return e.map((e=>({programIdIndex:findKeyIndex(e.programId),accountKeyIndexes:e.keys.map((e=>findKeyIndex(e.pubkey))),data:e.data})))}}const publicKey=(e="publicKey")=>ee.blob(32,e),signature=(e="signature")=>ee.blob(64,e),rustString=(e="string")=>{const t=ee.struct([ee.u32("length"),ee.u32("lengthPadding"),ee.blob(ee.offset(ee.u32(),-8),"chars")],e),r=t.decode.bind(t),n=t.encode.bind(t),s=t;return s.decode=(e,t)=>r(e,t).chars.toString(),s.encode=(e,t,r)=>{const s={chars:i.Buffer.from(e,"utf8")};return n(s,t,r)},s.alloc=e=>ee.u32().span+ee.u32().span+i.Buffer.from(e,"utf8").length,s};function getAlloc(e,t){const getItemAlloc=e=>{if(e.span>=0)return e.span;if("function"==typeof e.alloc)return e.alloc(t[e.property]);if("count"in e&&"elementLayout"in e){const r=t[e.property];if(Array.isArray(r))return r.length*getItemAlloc(e.elementLayout)}else if("fields"in e)return getAlloc({layout:e},t[e.property]);return 0};let r=0;return e.layout.fields.forEach((e=>{r+=getItemAlloc(e)})),r}function decodeLength(e){let t=0,r=0;for(;;){let n=e.shift();if(t|=(127&n)<<7*r,r+=1,!(128&n))break}return t}function encodeLength(e,t){let r=t;for(;;){let t=127&r;if(r>>=7,0==r){e.push(t);break}t|=128,e.push(t)}}function index_browser_esm_assert(e,t){if(!e)throw new Error(t||"Assertion failed")}class CompiledKeys{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,getOrInsertDefault=e=>{const t=e.toBase58();let n=r.get(t);return void 0===n&&(n={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(t,n)),n},n=getOrInsertDefault(t);n.isSigner=!0,n.isWritable=!0;for(const t of e){getOrInsertDefault(t.programId).isInvoked=!0;for(const e of t.keys){const t=getOrInsertDefault(e.pubkey);t.isSigner||=e.isSigner,t.isWritable||=e.isWritable}}return new CompiledKeys(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];index_browser_esm_assert(e.length<=256,"Max static account keys length exceeded");const t=e.filter((([,e])=>e.isSigner&&e.isWritable)),r=e.filter((([,e])=>e.isSigner&&!e.isWritable)),n=e.filter((([,e])=>!e.isSigner&&e.isWritable)),i=e.filter((([,e])=>!e.isSigner&&!e.isWritable)),s={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:i.length};{index_browser_esm_assert(t.length>0,"Expected at least one writable signer key");const[e]=t[0];index_browser_esm_assert(e===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[s,[...t.map((([e])=>new PublicKey(e))),...r.map((([e])=>new PublicKey(e))),...n.map((([e])=>new PublicKey(e))),...i.map((([e])=>new PublicKey(e)))]]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&e.isWritable)),[n,i]=this.drainKeysFoundInLookupTable(e.state.addresses,(e=>!e.isSigner&&!e.isInvoked&&!e.isWritable));if(0!==t.length||0!==n.length)return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:n},{writable:r,readonly:i}]}drainKeysFoundInLookupTable(e,t){const r=new Array,n=new Array;for(const[i,s]of this.keyMetaMap.entries())if(t(s)){const t=new PublicKey(i),s=e.findIndex((e=>e.equals(t)));s>=0&&(index_browser_esm_assert(s<256,"Max lookup table index exceeded"),r.push(s),n.push(t),this.keyMetaMap.delete(i))}return[r,n]}}const _e="Reached end of buffer unexpectedly";function guardedShift(e){if(0===e.length)throw new Error(_e);return e.shift()}function guardedSplice(e,...t){const[r]=t;if(2===t.length?r+(t[1]??0)>e.length:r>=e.length)throw new Error(_e);return e.splice(...t)}class Message{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map((e=>new PublicKey(e))),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach((e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex])))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:J().decode(e.data)})))}get addressTableLookups(){return[]}getAccountKeys(){return new MessageAccountKeys(this.staticAccountKeys)}static compile(e){const t=CompiledKeys.compile(e.instructions,e.payerKey),[r,n]=t.getMessageComponents(),i=new MessageAccountKeys(n).compileInstructions(e.instructions).map((e=>({programIdIndex:e.programIdIndex,accounts:e.accountKeyIndexes,data:J().encode(e.data)})));return new Message({header:r,accountKeys:n,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){return e-t<this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts}return e<t-this.header.numReadonlySignedAccounts}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((e,t)=>!this.isProgramId(t)))}serialize(){const e=this.accountKeys.length;let t=[];encodeLength(t,e);const r=this.instructions.map((e=>{const{accounts:t,programIdIndex:r}=e,n=Array.from(J().decode(e.data));let s=[];encodeLength(s,t.length);let o=[];return encodeLength(o,n.length),{programIdIndex:r,keyIndicesCount:i.Buffer.from(s),keyIndices:t,dataLength:i.Buffer.from(o),data:n}}));let n=[];encodeLength(n,r.length);let s=i.Buffer.alloc(Ae);i.Buffer.from(n).copy(s);let o=n.length;r.forEach((e=>{const t=ee.struct([ee.u8("programIdIndex"),ee.blob(e.keyIndicesCount.length,"keyIndicesCount"),ee.seq(ee.u8("keyIndex"),e.keyIndices.length,"keyIndices"),ee.blob(e.dataLength.length,"dataLength"),ee.seq(ee.u8("userdatum"),e.data.length,"data")]).encode(e,s,o);o+=t})),s=s.slice(0,o);const a=ee.struct([ee.blob(1,"numRequiredSignatures"),ee.blob(1,"numReadonlySignedAccounts"),ee.blob(1,"numReadonlyUnsignedAccounts"),ee.blob(t.length,"keyCount"),ee.seq(publicKey("key"),e,"keys"),publicKey("recentBlockhash")]),u={numRequiredSignatures:i.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:i.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:i.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:i.Buffer.from(t),keys:this.accountKeys.map((e=>toBuffer(e.toBytes()))),recentBlockhash:J().decode(this.recentBlockhash)};let c=i.Buffer.alloc(2048);const d=a.encode(u,c);return s.copy(c,d),c.slice(0,d+s.length)}static from(e){let t=[...e];const r=guardedShift(t);if(r!==(127&r))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const n=guardedShift(t),s=guardedShift(t),o=decodeLength(t);let a=[];for(let e=0;e<o;e++){const e=guardedSplice(t,0,Ee);a.push(new PublicKey(i.Buffer.from(e)))}const u=guardedSplice(t,0,Ee),c=decodeLength(t);let d=[];for(let e=0;e<c;e++){const e=guardedShift(t),r=guardedSplice(t,0,decodeLength(t)),n=guardedSplice(t,0,decodeLength(t)),s=J().encode(i.Buffer.from(n));d.push({programIdIndex:e,accounts:r,data:s})}const l={header:{numRequiredSignatures:r,numReadonlySignedAccounts:n,numReadonlyUnsignedAccounts:s},recentBlockhash:J().encode(i.Buffer.from(u)),accountKeys:a,instructions:d};return new Message(l)}}class MessageV0{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new MessageAccountKeys(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){return e-r<this.addressTableLookups.reduce(((e,t)=>e+t.writableIndexes.length),0)}if(e>=this.header.numRequiredSignatures){return e-t<r-t-this.header.numReadonlyUnsignedAccounts}return e<t-this.header.numReadonlySignedAccounts}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const n=e.find((e=>e.key.equals(r.accountKey)));if(!n)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const e of r.writableIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.writable.push(n.state.addresses[e])}for(const e of r.readonlyIndexes){if(!(e<n.state.addresses.length))throw new Error(`Failed to find address for index ${e} in address lookup table ${r.accountKey.toBase58()}`);t.readonly.push(n.state.addresses[e])}}return t}static compile(e){const t=CompiledKeys.compile(e.instructions,e.payerKey),r=new Array,n={writable:new Array,readonly:new Array},i=e.addressLookupTableAccounts||[];for(const e of i){const i=t.extractTableLookup(e);if(void 0!==i){const[e,{writable:t,readonly:s}]=i;r.push(e),n.writable.push(...t),n.readonly.push(...s)}}const[s,o]=t.getMessageComponents(),a=new MessageAccountKeys(o,n).compileInstructions(e.instructions);return new MessageV0({header:s,staticAccountKeys:o,recentBlockhash:e.recentBlockhash,compiledInstructions:a,addressTableLookups:r})}serialize(){const e=Array();encodeLength(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();encodeLength(r,this.compiledInstructions.length);const n=this.serializeAddressTableLookups(),i=Array();encodeLength(i,this.addressTableLookups.length);const s=ee.struct([ee.u8("prefix"),ee.struct([ee.u8("numRequiredSignatures"),ee.u8("numReadonlySignedAccounts"),ee.u8("numReadonlyUnsignedAccounts")],"header"),ee.blob(e.length,"staticAccountKeysLength"),ee.seq(publicKey(),this.staticAccountKeys.length,"staticAccountKeys"),publicKey("recentBlockhash"),ee.blob(r.length,"instructionsLength"),ee.blob(t.length,"serializedInstructions"),ee.blob(i.length,"addressTableLookupsLength"),ee.blob(n.length,"serializedAddressTableLookups")]),o=new Uint8Array(Ae),a=s.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map((e=>e.toBytes())),recentBlockhash:J().decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(i),serializedAddressTableLookups:n},o);return o.slice(0,a)}serializeInstructions(){let e=0;const t=new Uint8Array(Ae);for(const r of this.compiledInstructions){const n=Array();encodeLength(n,r.accountKeyIndexes.length);const i=Array();encodeLength(i,r.data.length);e+=ee.struct([ee.u8("programIdIndex"),ee.blob(n.length,"encodedAccountKeyIndexesLength"),ee.seq(ee.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),ee.blob(i.length,"encodedDataLength"),ee.blob(r.data.length,"data")]).encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(i),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Ae);for(const r of this.addressTableLookups){const n=Array();encodeLength(n,r.writableIndexes.length);const i=Array();encodeLength(i,r.readonlyIndexes.length);e+=ee.struct([publicKey("accountKey"),ee.blob(n.length,"encodedWritableIndexesLength"),ee.seq(ee.u8(),r.writableIndexes.length,"writableIndexes"),ee.blob(i.length,"encodedReadonlyIndexesLength"),ee.seq(ee.u8(),r.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(i),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=guardedShift(t),n=127&r;index_browser_esm_assert(r!==n,"Expected versioned message but received legacy message");index_browser_esm_assert(0===n,`Expected versioned message with version 0 but found version ${n}`);const i={numRequiredSignatures:guardedShift(t),numReadonlySignedAccounts:guardedShift(t),numReadonlyUnsignedAccounts:guardedShift(t)},s=[],o=decodeLength(t);for(let e=0;e<o;e++)s.push(new PublicKey(guardedSplice(t,0,Ee)));const a=J().encode(guardedSplice(t,0,Ee)),u=decodeLength(t),c=[];for(let e=0;e<u;e++){const e=guardedShift(t),r=guardedSplice(t,0,decodeLength(t)),n=decodeLength(t),i=new Uint8Array(guardedSplice(t,0,n));c.push({programIdIndex:e,accountKeyIndexes:r,data:i})}const d=decodeLength(t),l=[];for(let e=0;e<d;e++){const e=new PublicKey(guardedSplice(t,0,Ee)),r=guardedSplice(t,0,decodeLength(t)),n=guardedSplice(t,0,decodeLength(t));l.push({accountKey:e,writableIndexes:r,readonlyIndexes:n})}return new MessageV0({header:i,staticAccountKeys:s,recentBlockhash:a,compiledInstructions:c,addressTableLookups:l})}}const Le={deserializeMessageVersion(e){const t=e[0],r=127&t;return r===t?"legacy":r},deserialize:e=>{const t=Le.deserializeMessageVersion(e);if("legacy"===t)return Message.from(e);if(0===t)return MessageV0.deserialize(e);throw new Error(`Transaction message version ${t} deserialization is not supported`)}};const Te=i.Buffer.alloc(64).fill(0);class TransactionInstruction{constructor(e){this.keys=void 0,this.programId=void 0,this.data=i.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map((({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r}))),programId:this.programId.toJSON(),data:[...this.data]}}}class Transaction{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((e=>e.toJSON())),signers:this.signatures.map((({publicKey:e})=>e.toJSON()))}}add(...e){if(0===e.length)throw new Error("No instructions");return e.forEach((e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new TransactionInstruction(e))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t,r;if(this.nonceInfo?(e=this.nonceInfo.nonce,t=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");if(t.length<1&&console.warn("No instructions provided"),this.feePayer)r=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");r=this.signatures[0].publicKey}for(let e=0;e<t.length;e++)if(void 0===t[e].programId)throw new Error(`Transaction instruction index ${e} has undefined program id`);const n=[],i=[];t.forEach((e=>{e.keys.forEach((e=>{i.push({...e})}));const t=e.programId.toString();n.includes(t)||n.push(t)})),n.forEach((e=>{i.push({pubkey:new PublicKey(e),isSigner:!1,isWritable:!1})}));const s=[];i.forEach((e=>{const t=e.pubkey.toString(),r=s.findIndex((e=>e.pubkey.toString()===t));r>-1?(s[r].isWritable=s[r].isWritable||e.isWritable,s[r].isSigner=s[r].isSigner||e.isSigner):s.push(e)})),s.sort((function(e,t){if(e.isSigner!==t.isSigner)return e.isSigner?-1:1;if(e.isWritable!==t.isWritable)return e.isWritable?-1:1;return e.pubkey.toBase58().localeCompare(t.pubkey.toBase58(),"en",{localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"})}));const o=s.findIndex((e=>e.pubkey.equals(r)));if(o>-1){const[e]=s.splice(o,1);e.isSigner=!0,e.isWritable=!0,s.unshift(e)}else s.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const e of this.signatures){const t=s.findIndex((t=>t.pubkey.equals(e.publicKey)));if(!(t>-1))throw new Error(`unknown signer: ${e.publicKey.toString()}`);s[t].isSigner||(s[t].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let a=0,u=0,c=0;const d=[],l=[];s.forEach((({pubkey:e,isSigner:t,isWritable:r})=>{t?(d.push(e.toString()),a+=1,r||(u+=1)):(l.push(e.toString()),r||(c+=1))}));const f=d.concat(l),y=t.map((e=>{const{data:t,programId:r}=e;return{programIdIndex:f.indexOf(r.toString()),accounts:e.keys.map((e=>f.indexOf(e.pubkey.toString()))),data:J().encode(t)}}));return y.forEach((e=>{index_browser_esm_assert(e.programIdIndex>=0),e.accounts.forEach((e=>index_browser_esm_assert(e>=0)))})),new Message({header:{numRequiredSignatures:a,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:c},accountKeys:f,recentBlockhash:e,instructions:y})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);if(this.signatures.length===t.length){if(this.signatures.every(((e,r)=>t[r].equals(e.publicKey))))return e}return this.signatures=t.map((e=>({signature:null,publicKey:e}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(0===e.length)throw new Error("No signers");const t=new Set;this.signatures=e.filter((e=>{const r=e.toString();return!t.has(r)&&(t.add(r),!0)})).map((e=>({signature:null,publicKey:e})))}sign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const e=n.publicKey.toString();t.has(e)||(t.add(e),r.push(n))}this.signatures=r.map((e=>({signature:null,publicKey:e.publicKey})));const n=this._compile();this._partialSign(n,...r)}partialSign(...e){if(0===e.length)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const e=n.publicKey.toString();t.has(e)||(t.add(e),r.push(n))}const n=this._compile();this._partialSign(n,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach((e=>{const t=sign(r,e.secretKey);this._addSignature(e.publicKey,toBuffer(t))}))}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){index_browser_esm_assert(64===t.length);const r=this.signatures.findIndex((t=>e.equals(t.publicKey)));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=i.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const r={};for(const{signature:n,publicKey:i}of this.signatures)null===n?t&&(r.missing||=[]).push(i):Se(n,e,i.toBytes())||(r.invalid||=[]).push(i);return r.invalid||r.missing?r:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),n=this.serializeMessage();if(r){const e=this._getMessageSignednessErrors(n,t);if(e){let t="Signature verification failed.";throw e.invalid&&(t+=`\nInvalid signature for public key${1===e.invalid.length?"":"(s)"} [\`${e.invalid.map((e=>e.toBase58())).join("`, `")}\`].`),e.missing&&(t+=`\nMissing signature for public key${1===e.missing.length?"":"(s)"} [\`${e.missing.map((e=>e.toBase58())).join("`, `")}\`].`),new Error(t)}}return this._serialize(n)}_serialize(e){const{signatures:t}=this,r=[];encodeLength(r,t.length);const n=r.length+64*t.length+e.length,s=i.Buffer.alloc(n);return index_browser_esm_assert(t.length<256),i.Buffer.from(r).copy(s,0),t.forEach((({signature:e},t)=>{null!==e&&(index_browser_esm_assert(64===e.length,"signature has invalid length"),i.Buffer.from(e).copy(s,r.length+64*t))})),e.copy(s,r.length+64*t.length),index_browser_esm_assert(s.length<=Ae,`Transaction too large: ${s.length} > ${Ae}`),s}get keys(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].keys.map((e=>e.pubkey))}get programId(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].programId}get data(){return index_browser_esm_assert(1===this.instructions.length),this.instructions[0].data}static from(e){let t=[...e];const r=decodeLength(t);let n=[];for(let e=0;e<r;e++){const e=guardedSplice(t,0,64);n.push(J().encode(i.Buffer.from(e)))}return Transaction.populate(Message.from(t),n)}static populate(e,t=[]){const r=new Transaction;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach(((t,n)=>{const i={signature:t==J().encode(Te)?null:J().decode(t),publicKey:e.accountKeys[n]};r.signatures.push(i)})),e.instructions.forEach((t=>{const n=t.accounts.map((t=>{const n=e.accountKeys[t];return{pubkey:n,isSigner:r.signatures.some((e=>e.publicKey.toString()===n.toString()))||e.isAccountSigner(t),isWritable:e.isAccountWritable(t)}}));r.instructions.push(new TransactionInstruction({keys:n,programId:e.accountKeys[t.programIdIndex],data:J().decode(t.data)}))})),r._message=e,r._json=r.toJSON(),r}}class TransactionMessage{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:r,compiledInstructions:n,recentBlockhash:i}=e,{numRequiredSignatures:s,numReadonlySignedAccounts:o,numReadonlyUnsignedAccounts:a}=r,u=s-o;index_browser_esm_assert(u>0,"Message header is invalid");const c=e.staticAccountKeys.length-s-a;index_browser_esm_assert(c>=0,"Message header is invalid");const d=e.getAccountKeys(t),l=d.get(0);if(void 0===l)throw new Error("Failed to decompile message because no account keys were found");const f=[];for(const e of n){const t=[];for(const n of e.accountKeyIndexes){const e=d.get(n);if(void 0===e)throw new Error(`Failed to find key for account key index ${n}`);let i;i=n<s?n<u:n<d.staticAccountKeys.length?n-s<c:n-d.staticAccountKeys.length<d.accountKeysFromLookups.writable.length,t.push({pubkey:e,isSigner:n<r.numRequiredSignatures,isWritable:i})}const n=d.get(e.programIdIndex);if(void 0===n)throw new Error(`Failed to find program id for program id index ${e.programIdIndex}`);f.push(new TransactionInstruction({programId:n,data:toBuffer(e.data),keys:t}))}return new TransactionMessage({payerKey:l,instructions:f,recentBlockhash:i})}compileToLegacyMessage(){return Message.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return MessageV0.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class VersionedTransaction{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,void 0!==t)index_browser_esm_assert(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const t=[];for(let r=0;r<e.header.numRequiredSignatures;r++)t.push(new Uint8Array(64));this.signatures=t}this.message=e}serialize(){const e=this.message.serialize(),t=Array();encodeLength(t,this.signatures.length);const r=ee.struct([ee.blob(t.length,"encodedSignaturesLength"),ee.seq(signature(),this.signatures.length,"signatures"),ee.blob(e.length,"serializedMessage")]),n=new Uint8Array(2048),i=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},n);return n.slice(0,i)}static deserialize(e){let t=[...e];const r=[],n=decodeLength(t);for(let e=0;e<n;e++)r.push(new Uint8Array(guardedSplice(t,0,64)));const i=Le.deserialize(new Uint8Array(t));return new VersionedTransaction(i,r)}sign(e){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const n of e){const e=r.findIndex((e=>e.equals(n.publicKey)));index_browser_esm_assert(e>=0,`Cannot sign with non signer key ${n.publicKey.toBase58()}`),this.signatures[e]=sign(t,n.secretKey)}}addSignature(e,t){index_browser_esm_assert(64===t.byteLength,"Signature must be 64 bytes long");const r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex((t=>t.equals(e)));index_browser_esm_assert(r>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=t}}const Ne=new PublicKey("SysvarC1ock11111111111111111111111111111111"),We=(new PublicKey("SysvarEpochSchedu1e111111111111111111111111"),new PublicKey("Sysvar1nstructions1111111111111111111111111")),Ke=new PublicKey("SysvarRecentB1ockHashes11111111111111111111"),Oe=new PublicKey("SysvarRent111111111111111111111111111111111"),Re=(new PublicKey("SysvarRewards111111111111111111111111111111"),new PublicKey("SysvarS1otHashes111111111111111111111111111"),new PublicKey("SysvarS1otHistory11111111111111111111111111"),new PublicKey("SysvarStakeHistory1111111111111111111111111"));async function sendAndConfirmTransaction(e,t,r,n){const i=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},s=await e.sendTransaction(t,r,i);let o;if(null!=t.recentBlockhash&&null!=t.lastValidBlockHeight)o=(await e.confirmTransaction({abortSignal:n?.abortSignal,signature:s,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},n&&n.commitment)).value;else if(null!=t.minNonceContextSlot&&null!=t.nonceInfo){const{nonceInstruction:r}=t.nonceInfo,i=r.keys[0].pubkey;o=(await e.confirmTransaction({abortSignal:n?.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:i,nonceValue:t.nonceInfo.nonce,signature:s},n&&n.commitment)).value}else null!=n?.abortSignal&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),o=(await e.confirmTransaction(s,n&&n.commitment)).value;if(o.err)throw new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);return s}function sleep(e){return new Promise((t=>setTimeout(t,e)))}function encodeData(e,t){const r=e.layout.span>=0?e.layout.span:getAlloc(e,t),n=i.Buffer.alloc(r),s=Object.assign({instruction:e.index},t);return e.layout.encode(s,n),n}function decodeData$1(e,t){let r;try{r=e.layout.decode(t)}catch(e){throw new Error("invalid instruction; "+e)}if(r.instruction!==e.index)throw new Error(`invalid instruction; instruction index mismatch ${r.instruction} != ${e.index}`);return r}const je=ee.nu64("lamportsPerSignature"),ze=ee.struct([ee.u32("version"),ee.u32("state"),publicKey("authorizedPubkey"),publicKey("nonce"),ee.struct([je],"feeCalculator")]),Ce=ze.span;const qe=(Ue=8,e=>{const t=(0,ee.blob)(Ue,e),{encode:r,decode:n}=(e=>({decode:e.decode.bind(e),encode:e.encode.bind(e)}))(t),s=t;return s.decode=(e,t)=>{const r=n(e,t);return(0,te.toBigIntLE)(i.Buffer.from(r))},s.encode=(e,t,n)=>{const i=(0,te.toBufferLE)(e,Ue);return r(i,t,n)},s});var Ue;class SystemInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=ee.u32("instruction").decode(e.data);let r;for(const[e,n]of Object.entries(De))if(n.index==t){r=e;break}if(!r)throw new Error("Instruction type incorrect; not a SystemInstruction");return r}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:r,programId:n}=decodeData$1(De.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:r,programId:new PublicKey(n)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=decodeData$1(De.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:r,programId:n}=decodeData$1(De.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:r,programId:new PublicKey(n)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=decodeData$1(De.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,space:n,programId:i}=decodeData$1(De.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new PublicKey(t),seed:r,space:n,programId:new PublicKey(i)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=decodeData$1(De.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new PublicKey(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,programId:n}=decodeData$1(De.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new PublicKey(t),seed:r,programId:new PublicKey(n)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:r,lamports:n,space:i,programId:s}=decodeData$1(De.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new PublicKey(t),seed:r,lamports:n,space:i,programId:new PublicKey(s)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=decodeData$1(De.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new PublicKey(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),decodeData$1(De.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=decodeData$1(De.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=decodeData$1(De.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new PublicKey(t)}}static checkProgramId(e){if(!e.equals(SystemProgram.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const De=Object.freeze({Create:{index:0,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports"),ee.ns64("space"),publicKey("programId")])},Assign:{index:1,layout:ee.struct([ee.u32("instruction"),publicKey("programId")])},Transfer:{index:2,layout:ee.struct([ee.u32("instruction"),qe("lamports")])},CreateWithSeed:{index:3,layout:ee.struct([ee.u32("instruction"),publicKey("base"),rustString("seed"),ee.ns64("lamports"),ee.ns64("space"),publicKey("programId")])},AdvanceNonceAccount:{index:4,layout:ee.struct([ee.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:ee.struct([ee.u32("instruction"),publicKey("authorized")])},AuthorizeNonceAccount:{index:7,layout:ee.struct([ee.u32("instruction"),publicKey("authorized")])},Allocate:{index:8,layout:ee.struct([ee.u32("instruction"),ee.ns64("space")])},AllocateWithSeed:{index:9,layout:ee.struct([ee.u32("instruction"),publicKey("base"),rustString("seed"),ee.ns64("space"),publicKey("programId")])},AssignWithSeed:{index:10,layout:ee.struct([ee.u32("instruction"),publicKey("base"),rustString("seed"),publicKey("programId")])},TransferWithSeed:{index:11,layout:ee.struct([ee.u32("instruction"),qe("lamports"),rustString("seed"),publicKey("programId")])},UpgradeNonceAccount:{index:12,layout:ee.struct([ee.u32("instruction")])}});class SystemProgram{constructor(){}static createAccount(e){const t=encodeData(De.Create,{lamports:e.lamports,space:e.space,programId:toBuffer(e.programId.toBuffer())});return new TransactionInstruction({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:t})}static transfer(e){let t,r;if("basePubkey"in e){t=encodeData(De.TransferWithSeed,{lamports:BigInt(e.lamports),seed:e.seed,programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{t=encodeData(De.Transfer,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new TransactionInstruction({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){t=encodeData(De.AssignWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{t=encodeData(De.Assign,{programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=encodeData(De.CreateWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:toBuffer(e.programId.toBuffer())});let r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new TransactionInstruction({keys:r,programId:this.programId,data:t})}static createNonceAccount(e){const t=new Transaction;"basePubkey"in e&&"seed"in e?t.add(SystemProgram.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Ce,programId:this.programId})):t.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Ce,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=encodeData(De.InitializeNonceAccount,{authorized:toBuffer(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1}],programId:this.programId,data:t};return new TransactionInstruction(r)}static nonceAdvance(e){const t=encodeData(De.AdvanceNonceAccount),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t};return new TransactionInstruction(r)}static nonceWithdraw(e){const t=encodeData(De.WithdrawNonceAccount,{lamports:e.lamports});return new TransactionInstruction({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Ke,isSigner:!1,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static nonceAuthorize(e){const t=encodeData(De.AuthorizeNonceAccount,{authorized:toBuffer(e.newAuthorizedPubkey.toBuffer())});return new TransactionInstruction({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:t})}static allocate(e){let t,r;if("basePubkey"in e){t=encodeData(De.AllocateWithSeed,{base:toBuffer(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:toBuffer(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{t=encodeData(De.Allocate,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new TransactionInstruction({keys:r,programId:this.programId,data:t})}}SystemProgram.programId=new PublicKey("11111111111111111111111111111111");const Ye=Ae-300;class Loader{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Loader.chunkSize)+1+1)}static async load(e,t,r,n,s){{const i=await e.getMinimumBalanceForRentExemption(s.length),o=await e.getAccountInfo(r.publicKey,"confirmed");let a=null;if(null!==o){if(o.executable)return console.error("Program load failed, account is already executable"),!1;o.data.length!==s.length&&(a=a||new Transaction,a.add(SystemProgram.allocate({accountPubkey:r.publicKey,space:s.length}))),o.owner.equals(n)||(a=a||new Transaction,a.add(SystemProgram.assign({accountPubkey:r.publicKey,programId:n}))),o.lamports<i&&(a=a||new Transaction,a.add(SystemProgram.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:i-o.lamports})))}else a=(new Transaction).add(SystemProgram.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:i>0?i:1,space:s.length,programId:n}));null!==a&&await sendAndConfirmTransaction(e,a,[t,r],{commitment:"confirmed"})}const o=ee.struct([ee.u32("instruction"),ee.u32("offset"),ee.u32("bytesLength"),ee.u32("bytesLengthPadding"),ee.seq(ee.u8("byte"),ee.offset(ee.u32(),-8),"bytes")]),a=Loader.chunkSize;let u=0,c=s,d=[];for(;c.length>0;){const s=c.slice(0,a),l=i.Buffer.alloc(a+16);o.encode({instruction:0,offset:u,bytes:s,bytesLength:0,bytesLengthPadding:0},l);const f=(new Transaction).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:n,data:l});if(d.push(sendAndConfirmTransaction(e,f,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")){const e=4;await sleep(1e3/e)}u+=a,c=c.slice(a)}await Promise.all(d);{const s=ee.struct([ee.u32("instruction")]),o=i.Buffer.alloc(s.span);s.encode({instruction:1},o);const a=(new Transaction).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1}],programId:n,data:o}),u="processed",c=await e.sendTransaction(a,[t,r],{preflightCommitment:u}),{context:d,value:l}=await e.confirmTransaction({signature:c,lastValidBlockHeight:a.lastValidBlockHeight,blockhash:a.recentBlockhash},u);if(l.err)throw new Error(`Transaction ${c} failed (${JSON.stringify(l)})`);for(;;){try{if(await e.getSlot({commitment:u})>d.slot)break}catch{}await new Promise((e=>setTimeout(e,Math.round(200))))}}return!0}}Loader.chunkSize=Ye;new PublicKey("BPFLoader2111111111111111111111111111111111");Object.prototype.toString,Object.keys;Error;Error;globalThis.fetch;ne.A;class AddressLookupTableAccount{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=function decodeData(e,t){let r;try{r=e.layout.decode(t)}catch(e){throw new Error("invalid instruction; "+e)}if(r.typeIndex!==e.index)throw new Error(`invalid account data; account type mismatch ${r.typeIndex} != ${e.index}`);return r}(Fe,e),r=e.length-56;index_browser_esm_assert(r>=0,"lookup table is invalid"),index_browser_esm_assert(r%32==0,"lookup table is invalid");const n=r/32,{addresses:i}=ee.struct([ee.seq(publicKey(),n,"addresses")]).decode(e.slice(56));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:0!==t.authority.length?new PublicKey(t.authority[0]):void 0,addresses:i.map((e=>new PublicKey(e)))}}}const Fe={index:1,layout:ee.struct([ee.u32("typeIndex"),qe("deactivationSlot"),ee.nu64("lastExtendedSlot"),ee.u8("lastExtendedStartIndex"),ee.u8(),ee.seq(publicKey(),ee.offset(ee.u8(),-1),"authority")])};const He=(0,re.au)((0,re.KJ)(PublicKey),(0,re.Yj)(),(e=>new PublicKey(e))),Me=(0,re.PV)([(0,re.Yj)(),(0,re.eu)("base64")]),Ve=(0,re.au)((0,re.KJ)(i.Buffer),Me,(e=>i.Buffer.from(e[0],"base64")));function createRpcResult(e){return(0,re.KC)([(0,re.NW)({jsonrpc:(0,re.eu)("2.0"),id:(0,re.Yj)(),result:e}),(0,re.NW)({jsonrpc:(0,re.eu)("2.0"),id:(0,re.Yj)(),error:(0,re.NW)({code:(0,re.L5)(),message:(0,re.Yj)(),data:(0,re.lq)((0,re.bz)())})})])}const $e=createRpcResult((0,re.L5)());function jsonRpcResult(e){return(0,re.au)(createRpcResult(e),$e,(t=>"error"in t?t:{...t,result:(0,re.vt)(t.result,e)}))}function jsonRpcResultAndContext(e){return jsonRpcResult((0,re.NW)({context:(0,re.NW)({slot:(0,re.ai)()}),value:e}))}function notificationResultAndContext(e){return(0,re.NW)({context:(0,re.NW)({slot:(0,re.ai)()}),value:e})}const Ge=(0,re.NW)({foundation:(0,re.ai)(),foundationTerm:(0,re.ai)(),initial:(0,re.ai)(),taper:(0,re.ai)(),terminal:(0,re.ai)()}),Ze=(jsonRpcResult((0,re.YO)((0,re.me)((0,re.NW)({epoch:(0,re.ai)(),effectiveSlot:(0,re.ai)(),amount:(0,re.ai)(),postBalance:(0,re.ai)(),commission:(0,re.lq)((0,re.me)((0,re.ai)()))})))),(0,re.YO)((0,re.NW)({slot:(0,re.ai)(),prioritizationFee:(0,re.ai)()}))),Je=(0,re.NW)({total:(0,re.ai)(),validator:(0,re.ai)(),foundation:(0,re.ai)(),epoch:(0,re.ai)()}),Xe=(0,re.NW)({epoch:(0,re.ai)(),slotIndex:(0,re.ai)(),slotsInEpoch:(0,re.ai)(),absoluteSlot:(0,re.ai)(),blockHeight:(0,re.lq)((0,re.ai)()),transactionCount:(0,re.lq)((0,re.ai)())}),Qe=(0,re.NW)({slotsPerEpoch:(0,re.ai)(),leaderScheduleSlotOffset:(0,re.ai)(),warmup:(0,re.zM)(),firstNormalEpoch:(0,re.ai)(),firstNormalSlot:(0,re.ai)()}),et=(0,re.g1)((0,re.Yj)(),(0,re.YO)((0,re.ai)())),tt=(0,re.me)((0,re.KC)([(0,re.NW)({}),(0,re.Yj)()])),rt=(0,re.NW)({err:tt}),nt=(0,re.eu)("receivedSignature");(0,re.NW)({"solana-core":(0,re.Yj)(),"feature-set":(0,re.lq)((0,re.ai)())}),jsonRpcResultAndContext((0,re.NW)({err:(0,re.me)((0,re.KC)([(0,re.NW)({}),(0,re.Yj)()])),logs:(0,re.me)((0,re.YO)((0,re.Yj)())),accounts:(0,re.lq)((0,re.me)((0,re.YO)((0,re.me)((0,re.NW)({executable:(0,re.zM)(),owner:(0,re.Yj)(),lamports:(0,re.ai)(),data:(0,re.YO)((0,re.Yj)()),rentEpoch:(0,re.lq)((0,re.ai)())}))))),unitsConsumed:(0,re.lq)((0,re.ai)()),returnData:(0,re.lq)((0,re.me)((0,re.NW)({programId:(0,re.Yj)(),data:(0,re.PV)([(0,re.Yj)(),(0,re.eu)("base64")])})))})),jsonRpcResultAndContext((0,re.NW)({byIdentity:(0,re.g1)((0,re.Yj)(),(0,re.YO)((0,re.ai)())),range:(0,re.NW)({firstSlot:(0,re.ai)(),lastSlot:(0,re.ai)()})}));jsonRpcResult(Ge),jsonRpcResult(Je),jsonRpcResult(Ze),jsonRpcResult(Xe),jsonRpcResult(Qe),jsonRpcResult(et),jsonRpcResult((0,re.ai)()),jsonRpcResultAndContext((0,re.NW)({total:(0,re.ai)(),circulating:(0,re.ai)(),nonCirculating:(0,re.ai)(),nonCirculatingAccounts:(0,re.YO)(He)}));const it=(0,re.NW)({amount:(0,re.Yj)(),uiAmount:(0,re.me)((0,re.ai)()),decimals:(0,re.ai)(),uiAmountString:(0,re.lq)((0,re.Yj)())}),st=(jsonRpcResultAndContext((0,re.YO)((0,re.NW)({address:He,amount:(0,re.Yj)(),uiAmount:(0,re.me)((0,re.ai)()),decimals:(0,re.ai)(),uiAmountString:(0,re.lq)((0,re.Yj)())}))),jsonRpcResultAndContext((0,re.YO)((0,re.NW)({pubkey:He,account:(0,re.NW)({executable:(0,re.zM)(),owner:He,lamports:(0,re.ai)(),data:Ve,rentEpoch:(0,re.ai)()})}))),(0,re.NW)({program:(0,re.Yj)(),parsed:(0,re.L5)(),space:(0,re.ai)()})),ot=(jsonRpcResultAndContext((0,re.YO)((0,re.NW)({pubkey:He,account:(0,re.NW)({executable:(0,re.zM)(),owner:He,lamports:(0,re.ai)(),data:st,rentEpoch:(0,re.ai)()})}))),jsonRpcResultAndContext((0,re.YO)((0,re.NW)({lamports:(0,re.ai)(),address:He}))),(0,re.NW)({executable:(0,re.zM)(),owner:He,lamports:(0,re.ai)(),data:Ve,rentEpoch:(0,re.ai)()})),at=((0,re.NW)({pubkey:He,account:ot}),(0,re.au)((0,re.KC)([(0,re.KJ)(i.Buffer),st]),(0,re.KC)([Me,st]),(e=>Array.isArray(e)?(0,re.vt)(e,Ve):e))),ut=(0,re.NW)({executable:(0,re.zM)(),owner:He,lamports:(0,re.ai)(),data:at,rentEpoch:(0,re.ai)()}),ct=((0,re.NW)({pubkey:He,account:ut}),(0,re.NW)({state:(0,re.KC)([(0,re.eu)("active"),(0,re.eu)("inactive"),(0,re.eu)("activating"),(0,re.eu)("deactivating")]),active:(0,re.ai)(),inactive:(0,re.ai)()}),jsonRpcResult((0,re.YO)((0,re.NW)({signature:(0,re.Yj)(),slot:(0,re.ai)(),err:tt,memo:(0,re.me)((0,re.Yj)()),blockTime:(0,re.lq)((0,re.me)((0,re.ai)()))}))),jsonRpcResult((0,re.YO)((0,re.NW)({signature:(0,re.Yj)(),slot:(0,re.ai)(),err:tt,memo:(0,re.me)((0,re.Yj)()),blockTime:(0,re.lq)((0,re.me)((0,re.ai)()))}))),(0,re.NW)({subscription:(0,re.ai)(),result:notificationResultAndContext(ot)}),(0,re.NW)({pubkey:He,account:ot})),dt=((0,re.NW)({subscription:(0,re.ai)(),result:notificationResultAndContext(ct)}),(0,re.NW)({parent:(0,re.ai)(),slot:(0,re.ai)(),root:(0,re.ai)()})),lt=((0,re.NW)({subscription:(0,re.ai)(),result:dt}),(0,re.KC)([(0,re.NW)({type:(0,re.KC)([(0,re.eu)("firstShredReceived"),(0,re.eu)("completed"),(0,re.eu)("optimisticConfirmation"),(0,re.eu)("root")]),slot:(0,re.ai)(),timestamp:(0,re.ai)()}),(0,re.NW)({type:(0,re.eu)("createdBank"),parent:(0,re.ai)(),slot:(0,re.ai)(),timestamp:(0,re.ai)()}),(0,re.NW)({type:(0,re.eu)("frozen"),slot:(0,re.ai)(),timestamp:(0,re.ai)(),stats:(0,re.NW)({numTransactionEntries:(0,re.ai)(),numSuccessfulTransactions:(0,re.ai)(),numFailedTransactions:(0,re.ai)(),maxTransactionsPerEntry:(0,re.ai)()})}),(0,re.NW)({type:(0,re.eu)("dead"),slot:(0,re.ai)(),timestamp:(0,re.ai)(),err:(0,re.Yj)()})])),ht=((0,re.NW)({subscription:(0,re.ai)(),result:lt}),(0,re.NW)({subscription:(0,re.ai)(),result:notificationResultAndContext((0,re.KC)([rt,nt]))}),(0,re.NW)({subscription:(0,re.ai)(),result:(0,re.ai)()}),(0,re.NW)({pubkey:(0,re.Yj)(),gossip:(0,re.me)((0,re.Yj)()),tpu:(0,re.me)((0,re.Yj)()),rpc:(0,re.me)((0,re.Yj)()),version:(0,re.me)((0,re.Yj)())}),(0,re.NW)({votePubkey:(0,re.Yj)(),nodePubkey:(0,re.Yj)(),activatedStake:(0,re.ai)(),epochVoteAccount:(0,re.zM)(),epochCredits:(0,re.YO)((0,re.PV)([(0,re.ai)(),(0,re.ai)(),(0,re.ai)()])),commission:(0,re.ai)(),lastVote:(0,re.ai)(),rootSlot:(0,re.me)((0,re.ai)())})),ft=(jsonRpcResult((0,re.NW)({current:(0,re.YO)(ht),delinquent:(0,re.YO)(ht)})),(0,re.KC)([(0,re.eu)("processed"),(0,re.eu)("confirmed"),(0,re.eu)("finalized")])),yt=(0,re.NW)({slot:(0,re.ai)(),confirmations:(0,re.me)((0,re.ai)()),err:tt,confirmationStatus:(0,re.lq)(ft)}),pt=(jsonRpcResultAndContext((0,re.YO)((0,re.me)(yt))),jsonRpcResult((0,re.ai)()),(0,re.NW)({accountKey:He,writableIndexes:(0,re.YO)((0,re.ai)()),readonlyIndexes:(0,re.YO)((0,re.ai)())})),gt=(0,re.NW)({signatures:(0,re.YO)((0,re.Yj)()),message:(0,re.NW)({accountKeys:(0,re.YO)((0,re.Yj)()),header:(0,re.NW)({numRequiredSignatures:(0,re.ai)(),numReadonlySignedAccounts:(0,re.ai)(),numReadonlyUnsignedAccounts:(0,re.ai)()}),instructions:(0,re.YO)((0,re.NW)({accounts:(0,re.YO)((0,re.ai)()),data:(0,re.Yj)(),programIdIndex:(0,re.ai)()})),recentBlockhash:(0,re.Yj)(),addressTableLookups:(0,re.lq)((0,re.YO)(pt))})}),mt=(0,re.NW)({pubkey:He,signer:(0,re.zM)(),writable:(0,re.zM)(),source:(0,re.lq)((0,re.KC)([(0,re.eu)("transaction"),(0,re.eu)("lookupTable")]))}),bt=(0,re.NW)({accountKeys:(0,re.YO)(mt),signatures:(0,re.YO)((0,re.Yj)())}),wt=(0,re.NW)({parsed:(0,re.L5)(),program:(0,re.Yj)(),programId:He}),kt=(0,re.NW)({accounts:(0,re.YO)(He),data:(0,re.Yj)(),programId:He}),It=(0,re.KC)([kt,wt]),St=(0,re.KC)([(0,re.NW)({parsed:(0,re.L5)(),program:(0,re.Yj)(),programId:(0,re.Yj)()}),(0,re.NW)({accounts:(0,re.YO)((0,re.Yj)()),data:(0,re.Yj)(),programId:(0,re.Yj)()})]),Bt=(0,re.au)(It,St,(e=>"accounts"in e?(0,re.vt)(e,kt):(0,re.vt)(e,wt))),xt=(0,re.NW)({signatures:(0,re.YO)((0,re.Yj)()),message:(0,re.NW)({accountKeys:(0,re.YO)(mt),instructions:(0,re.YO)(Bt),recentBlockhash:(0,re.Yj)(),addressTableLookups:(0,re.lq)((0,re.me)((0,re.YO)(pt)))})}),vt=(0,re.NW)({accountIndex:(0,re.ai)(),mint:(0,re.Yj)(),owner:(0,re.lq)((0,re.Yj)()),uiTokenAmount:it}),Et=(0,re.NW)({writable:(0,re.YO)(He),readonly:(0,re.YO)(He)}),Pt=(0,re.NW)({err:tt,fee:(0,re.ai)(),innerInstructions:(0,re.lq)((0,re.me)((0,re.YO)((0,re.NW)({index:(0,re.ai)(),instructions:(0,re.YO)((0,re.NW)({accounts:(0,re.YO)((0,re.ai)()),data:(0,re.Yj)(),programIdIndex:(0,re.ai)()}))})))),preBalances:(0,re.YO)((0,re.ai)()),postBalances:(0,re.YO)((0,re.ai)()),logMessages:(0,re.lq)((0,re.me)((0,re.YO)((0,re.Yj)()))),preTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(vt))),postTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(vt))),loadedAddresses:(0,re.lq)(Et),computeUnitsConsumed:(0,re.lq)((0,re.ai)())}),At=(0,re.NW)({err:tt,fee:(0,re.ai)(),innerInstructions:(0,re.lq)((0,re.me)((0,re.YO)((0,re.NW)({index:(0,re.ai)(),instructions:(0,re.YO)(Bt)})))),preBalances:(0,re.YO)((0,re.ai)()),postBalances:(0,re.YO)((0,re.ai)()),logMessages:(0,re.lq)((0,re.me)((0,re.YO)((0,re.Yj)()))),preTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(vt))),postTokenBalances:(0,re.lq)((0,re.me)((0,re.YO)(vt))),loadedAddresses:(0,re.lq)(Et),computeUnitsConsumed:(0,re.lq)((0,re.ai)())}),_t=(0,re.KC)([(0,re.eu)(0),(0,re.eu)("legacy")]),Lt=(0,re.NW)({pubkey:(0,re.Yj)(),lamports:(0,re.ai)(),postBalance:(0,re.me)((0,re.ai)()),rewardType:(0,re.me)((0,re.Yj)()),commission:(0,re.lq)((0,re.me)((0,re.ai)()))}),Tt=(jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:gt,meta:(0,re.me)(Pt),version:(0,re.lq)(_t)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:bt,meta:(0,re.me)(Pt),version:(0,re.lq)(_t)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:xt,meta:(0,re.me)(At),version:(0,re.lq)(_t)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:bt,meta:(0,re.me)(At),version:(0,re.lq)(_t)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)()),blockHeight:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),transactions:(0,re.YO)((0,re.NW)({transaction:gt,meta:(0,re.me)(Pt)})),rewards:(0,re.lq)((0,re.YO)(Lt)),blockTime:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({blockhash:(0,re.Yj)(),previousBlockhash:(0,re.Yj)(),parentSlot:(0,re.ai)(),signatures:(0,re.YO)((0,re.Yj)()),blockTime:(0,re.me)((0,re.ai)())}))),jsonRpcResult((0,re.me)((0,re.NW)({slot:(0,re.ai)(),meta:(0,re.me)(Pt),blockTime:(0,re.lq)((0,re.me)((0,re.ai)())),transaction:gt,version:(0,re.lq)(_t)}))),jsonRpcResult((0,re.me)((0,re.NW)({slot:(0,re.ai)(),transaction:xt,meta:(0,re.me)(At),blockTime:(0,re.lq)((0,re.me)((0,re.ai)())),version:(0,re.lq)(_t)}))),jsonRpcResultAndContext((0,re.NW)({blockhash:(0,re.Yj)(),feeCalculator:(0,re.NW)({lamportsPerSignature:(0,re.ai)()})})),jsonRpcResultAndContext((0,re.NW)({blockhash:(0,re.Yj)(),lastValidBlockHeight:(0,re.ai)()})),jsonRpcResultAndContext((0,re.zM)()),(0,re.NW)({slot:(0,re.ai)(),numTransactions:(0,re.ai)(),numSlots:(0,re.ai)(),samplePeriodSecs:(0,re.ai)()})),Nt=(jsonRpcResult((0,re.YO)(Tt)),jsonRpcResultAndContext((0,re.me)((0,re.NW)({feeCalculator:(0,re.NW)({lamportsPerSignature:(0,re.ai)()})}))),jsonRpcResult((0,re.Yj)()),jsonRpcResult((0,re.Yj)()),(0,re.NW)({err:tt,logs:(0,re.YO)((0,re.Yj)()),signature:(0,re.Yj)()}));(0,re.NW)({result:notificationResultAndContext(Nt),subscription:(0,re.ai)()});class Keypair{constructor(e){this._keypair=void 0,this._keypair=e??generateKeypair()}static generate(){return new Keypair(generateKeypair())}static fromSecretKey(e,t){if(64!==e.byteLength)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const t=e.slice(0,32),n=Ie(t);for(let e=0;e<32;e++)if(r[e]!==n[e])throw new Error("provided secretKey is invalid")}return new Keypair({publicKey:r,secretKey:e})}static fromSeed(e){const t=Ie(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new Keypair({publicKey:t,secretKey:r})}get publicKey(){return new PublicKey(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const Wt=Object.freeze({CreateLookupTable:{index:0,layout:ee.struct([ee.u32("instruction"),qe("recentSlot"),ee.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:ee.struct([ee.u32("instruction")])},ExtendLookupTable:{index:2,layout:ee.struct([ee.u32("instruction"),qe(),ee.seq(publicKey(),ee.offset(ee.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:ee.struct([ee.u32("instruction")])},CloseLookupTable:{index:4,layout:ee.struct([ee.u32("instruction")])}});class AddressLookupTableProgram{constructor(){}static createLookupTable(e){const[t,r]=PublicKey.findProgramAddressSync([e.authority.toBuffer(),(0,te.toBufferLE)(BigInt(e.recentSlot),8)],this.programId),n=encodeData(Wt.CreateLookupTable,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}];return[new TransactionInstruction({programId:this.programId,keys:i,data:n}),t]}static freezeLookupTable(e){const t=encodeData(Wt.FreezeLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:r,data:t})}static extendLookupTable(e){const t=encodeData(Wt.ExtendLookupTable,{addresses:e.addresses.map((e=>e.toBytes()))}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:SystemProgram.programId,isSigner:!1,isWritable:!1}),new TransactionInstruction({programId:this.programId,keys:r,data:t})}static deactivateLookupTable(e){const t=encodeData(Wt.DeactivateLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new TransactionInstruction({programId:this.programId,keys:r,data:t})}static closeLookupTable(e){const t=encodeData(Wt.CloseLookupTable),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new TransactionInstruction({programId:this.programId,keys:r,data:t})}}AddressLookupTableProgram.programId=new PublicKey("AddressLookupTab1e1111111111111111111111111");class ComputeBudgetInstruction{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const t=ee.u8("instruction").decode(e.data);let r;for(const[e,n]of Object.entries(Kt))if(n.index==t){r=e;break}if(!r)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return r}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:r}=decodeData$1(Kt.RequestUnits,e.data);return{units:t,additionalFee:r}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=decodeData$1(Kt.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=decodeData$1(Kt.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=decodeData$1(Kt.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(ComputeBudgetProgram.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const Kt=Object.freeze({RequestUnits:{index:0,layout:ee.struct([ee.u8("instruction"),ee.u32("units"),ee.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:ee.struct([ee.u8("instruction"),ee.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:ee.struct([ee.u8("instruction"),ee.u32("units")])},SetComputeUnitPrice:{index:3,layout:ee.struct([ee.u8("instruction"),qe("microLamports")])}});class ComputeBudgetProgram{constructor(){}static requestUnits(e){const t=encodeData(Kt.RequestUnits,e);return new TransactionInstruction({keys:[],programId:this.programId,data:t})}static requestHeapFrame(e){const t=encodeData(Kt.RequestHeapFrame,e);return new TransactionInstruction({keys:[],programId:this.programId,data:t})}static setComputeUnitLimit(e){const t=encodeData(Kt.SetComputeUnitLimit,e);return new TransactionInstruction({keys:[],programId:this.programId,data:t})}static setComputeUnitPrice(e){const t=encodeData(Kt.SetComputeUnitPrice,{microLamports:BigInt(e.microLamports)});return new TransactionInstruction({keys:[],programId:this.programId,data:t})}}ComputeBudgetProgram.programId=new PublicKey("ComputeBudget111111111111111111111111111111");const Ot=ee.struct([ee.u8("numSignatures"),ee.u8("padding"),ee.u16("signatureOffset"),ee.u16("signatureInstructionIndex"),ee.u16("publicKeyOffset"),ee.u16("publicKeyInstructionIndex"),ee.u16("messageDataOffset"),ee.u16("messageDataSize"),ee.u16("messageInstructionIndex")]);class Ed25519Program{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,instructionIndex:s}=e;index_browser_esm_assert(32===t.length,`Public Key must be 32 bytes but received ${t.length} bytes`),index_browser_esm_assert(64===n.length,`Signature must be 64 bytes but received ${n.length} bytes`);const o=Ot.span,a=o+t.length,u=a+n.length,c=i.Buffer.alloc(u+r.length),d=null==s?65535:s;return Ot.encode({numSignatures:1,padding:0,signatureOffset:a,signatureInstructionIndex:d,publicKeyOffset:o,publicKeyInstructionIndex:d,messageDataOffset:u,messageDataSize:r.length,messageInstructionIndex:d},c),c.fill(t,o),c.fill(n,a),c.fill(r,u),new TransactionInstruction({keys:[],programId:Ed25519Program.programId,data:c})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;index_browser_esm_assert(64===t.length,`Private key must be 64 bytes but received ${t.length} bytes`);try{const e=Keypair.fromSecretKey(t),i=e.publicKey.toBytes(),s=sign(r,e.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:s,instructionIndex:n})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}Ed25519Program.programId=new PublicKey("Ed25519SigVerify111111111111111111111111111");ke.utils.isValidPrivateKey;const Rt=ke.getPublicKey,jt=ee.struct([ee.u8("numSignatures"),ee.u16("signatureOffset"),ee.u8("signatureInstructionIndex"),ee.u16("ethAddressOffset"),ee.u8("ethAddressInstructionIndex"),ee.u16("messageDataOffset"),ee.u16("messageDataSize"),ee.u8("messageInstructionIndex"),ee.blob(20,"ethAddress"),ee.blob(64,"signature"),ee.u8("recoveryId")]);class Secp256k1Program{constructor(){}static publicKeyToEthAddress(e){index_browser_esm_assert(64===e.length,`Public key must be 64 bytes but received ${e.length} bytes`);try{return i.Buffer.from((0,ie.lY)(toBuffer(e))).slice(-20)}catch(e){throw new Error(`Error constructing Ethereum address: ${e}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:n,recoveryId:i,instructionIndex:s}=e;return Secp256k1Program.createInstructionWithEthAddress({ethAddress:Secp256k1Program.publicKeyToEthAddress(t),message:r,signature:n,recoveryId:i,instructionIndex:s})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:n,recoveryId:s,instructionIndex:o=0}=e;let a;a="string"==typeof t?t.startsWith("0x")?i.Buffer.from(t.substr(2),"hex"):i.Buffer.from(t,"hex"):t,index_browser_esm_assert(20===a.length,`Address must be 20 bytes but received ${a.length} bytes`);const u=12+a.length,c=u+n.length+1,d=i.Buffer.alloc(jt.span+r.length);return jt.encode({numSignatures:1,signatureOffset:u,signatureInstructionIndex:o,ethAddressOffset:12,ethAddressInstructionIndex:o,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:o,signature:toBuffer(n),ethAddress:toBuffer(a),recoveryId:s},d),d.fill(toBuffer(r),jt.span),new TransactionInstruction({keys:[],programId:Secp256k1Program.programId,data:d})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:n}=e;index_browser_esm_assert(32===t.length,`Private key must be 32 bytes but received ${t.length} bytes`);try{const e=toBuffer(t),s=Rt(e,!1).slice(1),o=i.Buffer.from((0,ie.lY)(toBuffer(r))),[a,u]=((e,t)=>{const r=ke.sign(e,t);return[r.toCompactRawBytes(),r.recovery]})(o,e);return this.createInstructionWithPublicKey({publicKey:s,message:r,signature:a,recoveryId:u,instructionIndex:n})}catch(e){throw new Error(`Error creating instruction; ${e}`)}}}var zt;Secp256k1Program.programId=new PublicKey("KeccakSecp256k11111111111111111111111111111");const Ct=new PublicKey("StakeConfig11111111111111111111111111111111");class Lockup{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}zt=Lockup,Lockup.default=new zt(0,0,PublicKey.default);const qt=Object.freeze({Initialize:{index:0,layout:ee.struct([ee.u32("instruction"),((e="authorized")=>ee.struct([publicKey("staker"),publicKey("withdrawer")],e))(),((e="lockup")=>ee.struct([ee.ns64("unixTimestamp"),ee.ns64("epoch"),publicKey("custodian")],e))()])},Authorize:{index:1,layout:ee.struct([ee.u32("instruction"),publicKey("newAuthorized"),ee.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:ee.struct([ee.u32("instruction")])},Split:{index:3,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},Withdraw:{index:4,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},Deactivate:{index:5,layout:ee.struct([ee.u32("instruction")])},Merge:{index:7,layout:ee.struct([ee.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:ee.struct([ee.u32("instruction"),publicKey("newAuthorized"),ee.u32("stakeAuthorizationType"),rustString("authoritySeed"),publicKey("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class StakeProgram{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:n}=e,i=n||Lockup.default,s=encodeData(qt.Initialize,{authorized:{staker:toBuffer(r.staker.toBuffer()),withdrawer:toBuffer(r.withdrawer.toBuffer())},lockup:{unixTimestamp:i.unixTimestamp,epoch:i.epoch,custodian:toBuffer(i.custodian.toBuffer())}}),o={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1}],programId:this.programId,data:s};return new TransactionInstruction(o)}static createAccountWithSeed(e){const t=new Transaction;t.add(SystemProgram.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:i}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:i}))}static createAccount(e){const t=new Transaction;t.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:i}=e;return t.add(this.initialize({stakePubkey:r,authorized:n,lockup:i}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:n}=e,i=encodeData(qt.Delegate);return(new Transaction).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:Ne,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:Ct,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:i,custodianPubkey:s}=e,o=encodeData(qt.Authorize,{newAuthorized:toBuffer(n.toBuffer()),stakeAuthorizationType:i.index}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ne,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return s&&a.push({pubkey:s,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:a,programId:this.programId,data:o})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:n,authorityOwner:i,newAuthorizedPubkey:s,stakeAuthorizationType:o,custodianPubkey:a}=e,u=encodeData(qt.AuthorizeWithSeed,{newAuthorized:toBuffer(s.toBuffer()),stakeAuthorizationType:o.index,authoritySeed:n,authorityOwner:toBuffer(i.toBuffer())}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:Ne,isSigner:!1,isWritable:!1}];return a&&c.push({pubkey:a,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:c,programId:this.programId,data:u})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:n,lamports:i}=e,s=encodeData(qt.Split,{lamports:i});return new TransactionInstruction({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static split(e,t){const r=new Transaction;return r.add(SystemProgram.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),r.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,basePubkey:s,seed:o,lamports:a}=e,u=new Transaction;return u.add(SystemProgram.allocate({accountPubkey:i,basePubkey:s,seed:o,space:this.space,programId:this.programId})),t&&t>0&&u.add(SystemProgram.transfer({fromPubkey:e.authorizedPubkey,toPubkey:i,lamports:t})),u.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:n,splitStakePubkey:i,lamports:a}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:n}=e,i=encodeData(qt.Merge);return(new Transaction).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Ne,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:n,lamports:i,custodianPubkey:s}=e,o=encodeData(qt.Withdraw,{lamports:i}),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Ne,isSigner:!1,isWritable:!1},{pubkey:Re,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return s&&a.push({pubkey:s,isSigner:!0,isWritable:!1}),(new Transaction).add({keys:a,programId:this.programId,data:o})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,n=encodeData(qt.Deactivate);return(new Transaction).add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ne,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}}StakeProgram.programId=new PublicKey("Stake11111111111111111111111111111111111111"),StakeProgram.space=200;const Ut=Object.freeze({InitializeAccount:{index:0,layout:ee.struct([ee.u32("instruction"),((e="voteInit")=>ee.struct([publicKey("nodePubkey"),publicKey("authorizedVoter"),publicKey("authorizedWithdrawer"),ee.u8("commission")],e))()])},Authorize:{index:1,layout:ee.struct([ee.u32("instruction"),publicKey("newAuthorized"),ee.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:ee.struct([ee.u32("instruction"),ee.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:ee.struct([ee.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:ee.struct([ee.u32("instruction"),((e="voteAuthorizeWithSeedArgs")=>ee.struct([ee.u32("voteAuthorizationType"),publicKey("currentAuthorityDerivedKeyOwnerPubkey"),rustString("currentAuthorityDerivedKeySeed"),publicKey("newAuthorized")],e))()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class VoteProgram{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:n}=e,i=encodeData(Ut.InitializeAccount,{voteInit:{nodePubkey:toBuffer(n.nodePubkey.toBuffer()),authorizedVoter:toBuffer(n.authorizedVoter.toBuffer()),authorizedWithdrawer:toBuffer(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),s={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:Ne,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new TransactionInstruction(s)}static createAccount(e){const t=new Transaction;return t.add(SystemProgram.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:i}=e,s=encodeData(Ut.Authorize,{newAuthorized:toBuffer(n.toBuffer()),voteAuthorizationType:i.index}),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ne,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:o,programId:this.programId,data:s})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:i,voteAuthorizationType:s,votePubkey:o}=e,a=encodeData(Ut.AuthorizeWithSeed,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:toBuffer(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:toBuffer(i.toBuffer()),voteAuthorizationType:s.index}}),u=[{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Ne,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:u,programId:this.programId,data:a})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:i}=e,s=encodeData(Ut.Withdraw,{lamports:n}),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:o,programId:this.programId,data:s})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return VoteProgram.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,nodePubkey:n}=e,i=encodeData(Ut.UpdateValidatorIdentity),s=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new Transaction).add({keys:s,programId:this.programId,data:i})}}VoteProgram.programId=new PublicKey("Vote111111111111111111111111111111111111111"),VoteProgram.space=3762;new PublicKey("Va1idator1nfo111111111111111111111111111111"),(0,re.NW)({name:(0,re.Yj)(),website:(0,re.lq)((0,re.Yj)()),details:(0,re.lq)((0,re.Yj)()),keybaseUsername:(0,re.lq)((0,re.Yj)())});new PublicKey("Vote111111111111111111111111111111111111111"),ee.struct([publicKey("nodePubkey"),publicKey("authorizedWithdrawer"),ee.u8("commission"),ee.nu64(),ee.seq(ee.struct([ee.nu64("slot"),ee.u32("confirmationCount")]),ee.offset(ee.u32(),-8),"votes"),ee.u8("rootSlotValid"),ee.nu64("rootSlot"),ee.nu64(),ee.seq(ee.struct([ee.nu64("epoch"),publicKey("authorizedVoter")]),ee.offset(ee.u32(),-8),"authorizedVoters"),ee.struct([ee.seq(ee.struct([publicKey("authorizedPubkey"),ee.nu64("epochOfLastAuthorizedSwitch"),ee.nu64("targetEpoch")]),32,"buf"),ee.nu64("idx"),ee.u8("isEmpty")],"priorVoters"),ee.nu64(),ee.seq(ee.struct([ee.nu64("epoch"),ee.nu64("credits"),ee.nu64("prevCredits")]),ee.offset(ee.u32(),-8),"epochCredits"),ee.struct([ee.nu64("slot"),ee.nu64("timestamp")],"lastTimestamp")])},856115:(e,t,r)=>{"use strict";var n=r(901048).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.toBigIntLE=function toBigIntLE(e){{const t=n.from(e);t.reverse();const r=t.toString("hex");return 0===r.length?BigInt(0):BigInt(`0x${r}`)}},t.toBigIntBE=function toBigIntBE(e){{const t=e.toString("hex");return 0===t.length?BigInt(0):BigInt(`0x${t}`)}},t.toBufferLE=function toBufferLE(e,t){{const r=e.toString(16),i=n.from(r.padStart(2*t,"0").slice(0,2*t),"hex");return i.reverse(),i}},t.toBufferBE=function toBufferBE(e,t){{const r=e.toString(16);return n.from(r.padStart(2*t,"0").slice(0,2*t),"hex")}}},90366:e=>{var t=10,r=41,n=107,i=9,s=25,o=10;function inputBytes(e){return r+(e.script?e.script.length:n)}function outputBytes(e){return e.script?o+e.script.length+(e.script.length>=74?2:1):i+(e.script?e.script.length:s)}function dustThreshold(e,t){return 3*inputBytes({})}function transactionBytes(e,r){return t+e.reduce((function(e,t){return e+inputBytes(t)}),0)+r.reduce((function(e,t){return e+outputBytes(t)}),0)}function uintOrNaN(e){return"number"!=typeof e?NaN:isFinite(e)?Math.floor(e)!==e||e<0?NaN:e:NaN}function sumOrNaN(e){return e.reduce((function(e,t){return e+uintOrNaN(t.value)}),0)}var a=outputBytes({});e.exports={dustThreshold,finalize:function finalize(e,t,r){var n=transactionBytes(e,t),i=r*(n+a),s=sumOrNaN(e)-(sumOrNaN(t)+i);s>dustThreshold()&&(t=t.concat({value:s}));var o=sumOrNaN(e)-sumOrNaN(t);return isFinite(o)?{inputs:e,outputs:t,fee:o}:{fee:r*n}},inputBytes,outputBytes,sumOrNaN,sumForgiving:function sumForgiving(e){return e.reduce((function(e,t){return e+(isFinite(t.value)?t.value:0)}),0)},transactionBytes,uintOrNaN}},759499:(e,t,r)=>{"use strict";const n=r(354994).v4,i=r(393514),ClientBrowser=function(e,t){if(!(this instanceof ClientBrowser))return new ClientBrowser(e,t);t||(t={}),this.options={reviver:void 0!==t.reviver?t.reviver:null,replacer:void 0!==t.replacer?t.replacer:null,generator:void 0!==t.generator?t.generator:function(){return n()},version:void 0!==t.version?t.version:2,notificationIdNull:"boolean"==typeof t.notificationIdNull&&t.notificationIdNull},this.callServer=e};e.exports=ClientBrowser,ClientBrowser.prototype.request=function(e,t,r,n){const s=this;let o=null;const a=Array.isArray(e)&&"function"==typeof t;if(1===this.options.version&&a)throw new TypeError("JSON-RPC 1.0 does not support batching");if(a||!a&&e&&"object"==typeof e&&"function"==typeof t)n=t,o=e;else{"function"==typeof r&&(n=r,r=void 0);const s="function"==typeof n;try{o=i(e,t,r,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(e){if(s)return n(e);throw e}if(!s)return o}let u;try{u=JSON.stringify(o,this.options.replacer)}catch(e){return n(e)}return this.callServer(u,(function(e,t){s._parseResponse(e,t,n)})),o},ClientBrowser.prototype._parseResponse=function(e,t,r){if(e)return void r(e);if(!t)return r();let n;try{n=JSON.parse(t,this.options.reviver)}catch(e){return r(e)}if(3===r.length){if(Array.isArray(n)){const isError=function(e){return void 0!==e.error},isNotError=function(e){return!isError(e)};return r(null,n.filter(isError),n.filter(isNotError))}return r(null,n.error,n.result)}r(null,n)}},393514:(e,t,r)=>{"use strict";const n=r(354994).v4;e.exports=function(e,t,r,i){if("string"!=typeof e)throw new TypeError(e+" must be a string");const s="number"==typeof(i=i||{}).version?i.version:2;if(1!==s&&2!==s)throw new TypeError(s+" must be 1 or 2");const o={method:e};if(2===s&&(o.jsonrpc="2.0"),t){if("object"!=typeof t&&!Array.isArray(t))throw new TypeError(t+" must be an object, array or omitted");o.params=t}if(void 0===r){const e="function"==typeof i.generator?i.generator:function(){return n()};o.id=e(o,i)}else 2===s&&null===r?i.notificationIdNull&&(o.id=null):o.id=r;return o}},354994:(e,t,r)=>{"use strict";var n;r.d(t,{v4:()=>d});var i=new Uint8Array(16);function rng(){if(!n&&!(n="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return n(i)}const s=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;const o=function validate(e){return"string"==typeof e&&s.test(e)};for(var a=[],u=0;u<256;++u)a.push((u+256).toString(16).substr(1));const c=function stringify(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=(a[e[t+0]]+a[e[t+1]]+a[e[t+2]]+a[e[t+3]]+"-"+a[e[t+4]]+a[e[t+5]]+"-"+a[e[t+6]]+a[e[t+7]]+"-"+a[e[t+8]]+a[e[t+9]]+"-"+a[e[t+10]]+a[e[t+11]]+a[e[t+12]]+a[e[t+13]]+a[e[t+14]]+a[e[t+15]]).toLowerCase();if(!o(r))throw TypeError("Stringified UUID is invalid");return r};const d=function v4(e,t,r){var n=(e=e||{}).random||(e.rng||rng)();if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,t){r=r||0;for(var i=0;i<16;++i)t[r+i]=n[i];return t}return c(n)}},516246:(e,t,r)=>{"use strict";var n=r(901048).Buffer,i=r(204293);t.A=void 0;var s=i(r(575799)),o=i(r(199436)),a=i(r(114319)),u=i(r(105018)),c=i(r(244668)),d=i(r(940906)),l=i(r(563315)),f=i(r(730409)),y=r(828985),p=r(839768);function _createSuper(e){var t=function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function _createSuperInternal(){var r,n=(0,f.default)(e);if(t){var i=(0,f.default)(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return(0,l.default)(this,r)}}var __rest=function(e,t){var r={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(n=Object.getOwnPropertySymbols(e);i<n.length;i++)t.indexOf(n[i])<0&&Object.prototype.propertyIsEnumerable.call(e,n[i])&&(r[n[i]]=e[n[i]])}return r},g=function(e){(0,d.default)(CommonClient,e);var t,r,i,l,f=_createSuper(CommonClient);function CommonClient(e){var t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"ws://localhost:8080",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;(0,u.default)(this,CommonClient);var o=n.autoconnect,a=void 0===o||o,c=n.reconnect,d=void 0===c||c,l=n.reconnect_interval,y=void 0===l?1e3:l,g=n.max_reconnects,m=void 0===g?5:g,b=__rest(n,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return(t=f.call(this)).webSocketFactory=e,t.queue={},t.rpc_id=0,t.address=r,t.autoconnect=a,t.ready=!1,t.reconnect=d,t.reconnect_timer_id=void 0,t.reconnect_interval=y,t.max_reconnects=m,t.rest_options=b,t.current_reconnects=0,t.generate_request_id=i||function(){return++t.rpc_id},t.dataPack=s||new p.DefaultDataPack,t.autoconnect&&t._connect(t.address,Object.assign({autoconnect:t.autoconnect,reconnect:t.reconnect,reconnect_interval:t.reconnect_interval,max_reconnects:t.max_reconnects},t.rest_options)),t}return(0,c.default)(CommonClient,[{key:"connect",value:function connect(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function call(e,t,r,n){var i=this;return n||"object"!==(0,a.default)(r)||(n=r,r=null),new Promise((function(s,o){if(!i.ready)return o(new Error("socket not ready"));var a=i.generate_request_id(e,t),u={jsonrpc:"2.0",method:e,params:t||void 0,id:a};i.socket.send(i.dataPack.encode(u),n,(function(e){if(e)return o(e);i.queue[a]={promise:[s,o]},r&&(i.queue[a].timeout=setTimeout((function(){delete i.queue[a],o(new Error("reply timeout"))}),r))}))}))}},{key:"login",value:(l=(0,o.default)(s.default.mark((function _callee(e){var t;return s.default.wrap((function _callee$(r){for(;;)switch(r.prev=r.next){case 0:return r.next=2,this.call("rpc.login",e);case 2:if(t=r.sent){r.next=5;break}throw new Error("authentication failed");case 5:return r.abrupt("return",t);case 6:case"end":return r.stop()}}),_callee,this)}))),function login(e){return l.apply(this,arguments)})},{key:"listMethods",value:(i=(0,o.default)(s.default.mark((function _callee2(){return s.default.wrap((function _callee2$(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.call("__listMethods");case 2:return e.abrupt("return",e.sent);case 3:case"end":return e.stop()}}),_callee2,this)}))),function listMethods(){return i.apply(this,arguments)})},{key:"notify",value:function notify(e,t){var r=this;return new Promise((function(n,i){if(!r.ready)return i(new Error("socket not ready"));var s={jsonrpc:"2.0",method:e,params:t};r.socket.send(r.dataPack.encode(s),(function(e){if(e)return i(e);n()}))}))}},{key:"subscribe",value:(r=(0,o.default)(s.default.mark((function _callee3(e){var t;return s.default.wrap((function _callee3$(r){for(;;)switch(r.prev=r.next){case 0:return"string"==typeof e&&(e=[e]),r.next=3,this.call("rpc.on",e);case 3:if(t=r.sent,"string"!=typeof e||"ok"===t[e]){r.next=6;break}throw new Error("Failed subscribing to an event '"+e+"' with: "+t[e]);case 6:return r.abrupt("return",t);case 7:case"end":return r.stop()}}),_callee3,this)}))),function subscribe(e){return r.apply(this,arguments)})},{key:"unsubscribe",value:(t=(0,o.default)(s.default.mark((function _callee4(e){var t;return s.default.wrap((function _callee4$(r){for(;;)switch(r.prev=r.next){case 0:return"string"==typeof e&&(e=[e]),r.next=3,this.call("rpc.off",e);case 3:if(t=r.sent,"string"!=typeof e||"ok"===t[e]){r.next=6;break}throw new Error("Failed unsubscribing from an event with: "+t);case 6:return r.abrupt("return",t);case 7:case"end":return r.stop()}}),_callee4,this)}))),function unsubscribe(e){return t.apply(this,arguments)})},{key:"close",value:function close(e,t){this.socket.close(e||1e3,t)}},{key:"_connect",value:function _connect(e,t){var r=this;clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(e,t),this.socket.addEventListener("open",(function(){r.ready=!0,r.emit("open"),r.current_reconnects=0})),this.socket.addEventListener("message",(function(e){var t=e.data;t instanceof ArrayBuffer&&(t=n.from(t).toString());try{t=r.dataPack.decode(t)}catch(e){return}if(t.notification&&r.listeners(t.notification).length){if(!Object.keys(t.params).length)return r.emit(t.notification);var i=[t.notification];if(t.params.constructor===Object)i.push(t.params);else for(var s=0;s<t.params.length;s++)i.push(t.params[s]);return Promise.resolve().then((function(){r.emit.apply(r,i)}))}if(!r.queue[t.id])return t.method?Promise.resolve().then((function(){r.emit(t.method,null==t?void 0:t.params)})):void 0;"error"in t=="result"in t&&r.queue[t.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),r.queue[t.id].timeout&&clearTimeout(r.queue[t.id].timeout),t.error?r.queue[t.id].promise[1](t.error):r.queue[t.id].promise[0](t.result),delete r.queue[t.id]})),this.socket.addEventListener("error",(function(e){return r.emit("error",e)})),this.socket.addEventListener("close",(function(n){var i=n.code,s=n.reason;r.ready&&setTimeout((function(){return r.emit("close",i,s)}),0),r.ready=!1,r.socket=void 0,1e3!==i&&(r.current_reconnects++,r.reconnect&&(r.max_reconnects>r.current_reconnects||0===r.max_reconnects)&&(r.reconnect_timer_id=setTimeout((function(){return r._connect(e,t)}),r.reconnect_interval)))}))}}]),CommonClient}(y.EventEmitter);t.A=g},885364:(e,t,r)=>{"use strict";var n=r(204293);t.A=function _default(e,t){return new c(e,t)};var i=n(r(105018)),s=n(r(244668)),o=n(r(940906)),a=n(r(563315)),u=n(r(730409));function _createSuper(e){var t=function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function _createSuperInternal(){var r,n=(0,u.default)(e);if(t){var i=(0,u.default)(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return(0,a.default)(this,r)}}var c=function(e){(0,o.default)(WebSocketBrowserImpl,e);var t=_createSuper(WebSocketBrowserImpl);function WebSocketBrowserImpl(e,r,n){var s;return(0,i.default)(this,WebSocketBrowserImpl),(s=t.call(this)).socket=new window.WebSocket(e,n),s.socket.onopen=function(){return s.emit("open")},s.socket.onmessage=function(e){return s.emit("message",e.data)},s.socket.onerror=function(e){return s.emit("error",e)},s.socket.onclose=function(e){s.emit("close",e.code,e.reason)},s}return(0,s.default)(WebSocketBrowserImpl,[{key:"send",value:function send(e,t,r){var n=r||t;try{this.socket.send(e),n()}catch(e){n(e)}}},{key:"close",value:function close(e,t){this.socket.close(e,t)}},{key:"addEventListener",value:function addEventListener(e,t,r){this.socket.addEventListener(e,t,r)}}]),WebSocketBrowserImpl}(r(828985).EventEmitter)},839768:(e,t,r)=>{"use strict";var n=r(204293);Object.defineProperty(t,"__esModule",{value:!0}),t.DefaultDataPack=void 0,t.createError=function createError(e,t){var r={code:e,message:o.get(e)||"Internal Server Error"};t&&(r.data=t);return r};var i=n(r(105018)),s=n(r(244668)),o=new Map([[-32e3,"Event not provided"],[-32600,"Invalid Request"],[-32601,"Method not found"],[-32602,"Invalid params"],[-32603,"Internal error"],[-32604,"Params not found"],[-32605,"Method forbidden"],[-32606,"Event forbidden"],[-32700,"Parse error"]]),a=function(){function DefaultDataPack(){(0,i.default)(this,DefaultDataPack)}return(0,s.default)(DefaultDataPack,[{key:"encode",value:function encode(e){return JSON.stringify(e)}},{key:"decode",value:function decode(e){return JSON.parse(e)}}]),DefaultDataPack}();t.DefaultDataPack=a},204293:e=>{e.exports=function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}},e.exports.__esModule=!0,e.exports.default=e.exports},727801:(e,t,r)=>{"use strict";r.d(t,{KC:()=>union,KJ:()=>instance,L5:()=>unknown,NW:()=>type,PV:()=>tuple,YO:()=>array,Yj:()=>string,ai:()=>number,au:()=>coerce,bz:()=>any,eu:()=>literal,g1:()=>record,lq:()=>optional,me:()=>nullable,vA:()=>assert,vt:()=>create,zM:()=>boolean});class StructError extends TypeError{constructor(e,t){let r;const{message:n,...i}=e,{path:s}=e;super(0===s.length?n:"At path: "+s.join(".")+" -- "+n),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>{var n;return null!=(n=r)?n:r=[e,...t()]}}}function isObject(e){return"object"==typeof e&&null!=e}function print(e){return"string"==typeof e?JSON.stringify(e):""+e}function toFailure(e,t,r,n){if(!0===e)return;!1===e?e={}:"string"==typeof e&&(e={message:e});const{path:i,branch:s}=t,{type:o}=r,{refinement:a,message:u="Expected a value of type `"+o+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+print(n)+"`"}=e;return{value:n,type:o,refinement:a,key:i[i.length-1],path:i,branch:s,...e,message:u}}function*toFailures(e,t,r,n){(function isIterable(e){return isObject(e)&&"function"==typeof e[Symbol.iterator]})(e)||(e=[e]);for(const i of e){const e=toFailure(i,t,r,n);e&&(yield e)}}function*run(e,t,r={}){const{path:n=[],branch:i=[e],coerce:s=!1,mask:o=!1}=r,a={path:n,branch:i};if(s&&(e=t.coercer(e,a),o&&"type"!==t.type&&isObject(t.schema)&&isObject(e)&&!Array.isArray(e)))for(const r in e)void 0===t.schema[r]&&delete e[r];let u=!0;for(const r of t.validator(e,a))u=!1,yield[r,void 0];for(let[r,c,d]of t.entries(e,a)){const t=run(c,d,{path:void 0===r?n:[...n,r],branch:void 0===r?i:[...i,c],coerce:s,mask:o});for(const n of t)n[0]?(u=!1,yield[n[0],void 0]):s&&(c=n[1],void 0===r?e=c:e instanceof Map?e.set(r,c):e instanceof Set?e.add(c):isObject(e)&&(e[r]=c))}if(u)for(const r of t.refiner(e,a))u=!1,yield[r,void 0];u&&(yield[void 0,e])}class Struct{constructor(e){const{type:t,schema:r,validator:n,refiner:i,coercer:s=(e=>e),entries:o=function*(){}}=e;this.type=t,this.schema=r,this.entries=o,this.coercer=s,this.validator=n?(e,t)=>toFailures(n(e,t),t,this,e):()=>[],this.refiner=i?(e,t)=>toFailures(i(e,t),t,this,e):()=>[]}assert(e){return assert(e,this)}create(e){return create(e,this)}is(e){return is(e,this)}mask(e){return function mask(e,t){const r=validate(e,t,{coerce:!0,mask:!0});if(r[0])throw r[0];return r[1]}(e,this)}validate(e,t={}){return validate(e,this,t)}}function assert(e,t){const r=validate(e,t);if(r[0])throw r[0]}function create(e,t){const r=validate(e,t,{coerce:!0});if(r[0])throw r[0];return r[1]}function is(e,t){return!validate(e,t)[0]}function validate(e,t,r={}){const n=run(e,t,r),i=function shiftIterator(e){const{done:t,value:r}=e.next();return t?void 0:r}(n);if(i[0]){return[new StructError(i[0],(function*(){for(const e of n)e[0]&&(yield e[0])})),void 0]}return[void 0,i[1]]}function define(e,t){return new Struct({type:e,schema:null,validator:t})}function any(){return define("any",(()=>!0))}function array(e){return new Struct({type:"array",schema:e,*entries(t){if(e&&Array.isArray(t))for(const[r,n]of t.entries())yield[r,n,e]},coercer:e=>Array.isArray(e)?e.slice():e,validator:e=>Array.isArray(e)||"Expected an array value, but received: "+print(e)})}function boolean(){return define("boolean",(e=>"boolean"==typeof e))}function instance(e){return define("instance",(t=>t instanceof e||"Expected a `"+e.name+"` instance, but received: "+print(t)))}function literal(e){const t=print(e),r=typeof e;return new Struct({type:"literal",schema:"string"===r||"number"===r||"boolean"===r?e:null,validator:r=>r===e||"Expected the literal `"+t+"`, but received: "+print(r)})}function never(){return define("never",(()=>!1))}function nullable(e){return new Struct({...e,validator:(t,r)=>null===t||e.validator(t,r),refiner:(t,r)=>null===t||e.refiner(t,r)})}function number(){return define("number",(e=>"number"==typeof e&&!isNaN(e)||"Expected a number, but received: "+print(e)))}function optional(e){return new Struct({...e,validator:(t,r)=>void 0===t||e.validator(t,r),refiner:(t,r)=>void 0===t||e.refiner(t,r)})}function record(e,t){return new Struct({type:"record",schema:null,*entries(r){if(isObject(r))for(const n in r){const i=r[n];yield[n,n,e],yield[n,i,t]}},validator:e=>isObject(e)||"Expected an object, but received: "+print(e)})}function string(){return define("string",(e=>"string"==typeof e||"Expected a string, but received: "+print(e)))}function tuple(e){const t=never();return new Struct({type:"tuple",schema:null,*entries(r){if(Array.isArray(r)){const n=Math.max(e.length,r.length);for(let i=0;i<n;i++)yield[i,r[i],e[i]||t]}},validator:e=>Array.isArray(e)||"Expected an array, but received: "+print(e)})}function type(e){const t=Object.keys(e);return new Struct({type:"type",schema:e,*entries(r){if(isObject(r))for(const n of t)yield[n,r[n],e[n]]},validator:e=>isObject(e)||"Expected an object, but received: "+print(e)})}function union(e){const t=e.map((e=>e.type)).join(" | ");return new Struct({type:"union",schema:null,validator(r,n){const i=[];for(const t of e){const[...e]=run(r,t,n),[s]=e;if(!s[0])return[];for(const[t]of e)t&&i.push(t)}return["Expected the value to satisfy a union of `"+t+"`, but received: "+print(r),...i]}})}function unknown(){return define("unknown",(()=>!0))}function coerce(e,t,r){return new Struct({...e,coercer:(n,i)=>is(n,t)?e.coercer(r(n,i),i):e.coercer(n,i)})}}}]);
//# sourceMappingURL=46709.1b8624de78.chunk.js.map