{"version":3,"file":"static/js/31517.53e29f3036.chunk.js","mappings":"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","sources":["webpack://web/../../packages/core/src/base/ChainSigner.ts","webpack://web/../../packages/core/src/base/CoreChainApiBase.ts","webpack://web/../../packages/core/src/chains/cfx/CoreChainHd.ts","webpack://web/../../node_modules/cip-23/node_modules/superstruct/lib/index.es.js","webpack://web/../../node_modules/cip-23/lib/es/types.js","webpack://web/../../node_modules/cip-23/lib/es/utils/buffer.js","webpack://web/../../node_modules/@findeth/abi/lib/es/utils/buffer.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/bytes.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/fixed-bytes.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/number.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/array.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/address.js","webpack://web/../../node_modules/@findeth/abi/lib/es/utils/twos-complement.js","webpack://web/../../node_modules/@findeth/abi/lib/es/parsers/string.js","webpack://web/../../node_modules/@findeth/abi/lib/es/abi.js","webpack://web/../../node_modules/cip-23/lib/es/utils/abi.js","webpack://web/../../node_modules/cip-23/lib/es/cip-23.js","webpack://web/../../node_modules/cip-23/lib/es/utils/json.js","webpack://web/../../packages/core/src/chains/cfx/CoreChainSoftware.ts","webpack://web/../../packages/core/src/utils/index.ts","webpack://web/../../node_modules/coinselect/utils.js"],"sourcesContent":["import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import _createClass from\"@babel/runtime/helpers/createClass\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));}catch(t){}return(_isNativeReflectConstruct=function(){return!!t;})();}import bufferUtils from'@onekeyhq/shared/src/utils/bufferUtils';import{N,decrypt,sign as _sign,uncompressPublicKey,verify}from\"../secret\";export var Verifier=function(){function Verifier(pub,curve){this.curve=curve;this.compressedPublicKey=Buffer.from(pub,'hex');this.uncompressedPublicKey=uncompressPublicKey(curve,this.compressedPublicKey);}var _proto=Verifier.prototype;_proto.getPubkey=function getPubkey(compressed){return Promise.resolve(compressed?this.compressedPublicKey:this.uncompressedPublicKey);};_proto.getPubkeyHex=function(){var _getPubkeyHex=_asyncToGenerator(function*(compressed){return bufferUtils.bytesToHex(yield this.getPubkey(compressed));});function getPubkeyHex(_x){return _getPubkeyHex.apply(this,arguments);}return getPubkeyHex;}();_proto.verify=function verify(){return Promise.resolve(Buffer.from([]));};_proto.verifySignature=function verifySignature({publicKey,digest,signature}){var p=bufferUtils.toBuffer(publicKey);var d=bufferUtils.toBuffer(digest);var s=bufferUtils.toBuffer(signature);var{curve}=this;var result=verify(curve,p,d,s);return Promise.resolve(result);};return _createClass(Verifier);}();export var ChainSigner=function(_Verifier){_inherits(ChainSigner,_Verifier);var _super=_createSuper(ChainSigner);function ChainSigner(encryptedPrivateKey,password,curve){var _this;var pub=N(curve,{key:encryptedPrivateKey,chainCode:Buffer.alloc(32)},password).key.toString('hex');_this=_super.call(this,pub,curve);_this.encryptedPrivateKey=encryptedPrivateKey;_this.password=password;_this.curve=curve;return _this;}var _proto2=ChainSigner.prototype;_proto2.getPrvkey=function getPrvkey(){return Promise.resolve(decrypt(this.password,this.encryptedPrivateKey));};_proto2.getPrvkeyHex=function(){var _getPrvkeyHex=_asyncToGenerator(function*(){return bufferUtils.bytesToHex(yield this.getPrvkey());});function getPrvkeyHex(){return _getPrvkeyHex.apply(this,arguments);}return getPrvkeyHex;}();_proto2.sign=function sign(digest){var signature=_sign(this.curve,this.encryptedPrivateKey,digest,this.password);if(this.curve==='secp256k1'){return Promise.resolve([signature.slice(0,-1),signature[signature.length-1]]);}return Promise.resolve([signature,0]);};return _createClass(ChainSigner);}(Verifier);","import _merge from\"lodash/merge\";import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import _createClass from\"@babel/runtime/helpers/createClass\";function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}import{NotImplemented,OneKeyInternalError}from'@onekeyhq/shared/src/errors';import bufferUtils from'@onekeyhq/shared/src/utils/bufferUtils';import{batchGetPrivateKeys,batchGetPublicKeysAsync,decrypt,decryptImportedCredential,ed25519,encrypt,nistp256,secp256k1}from\"../secret\";import{ECoreCredentialType}from\"../types\";import{slicePathTemplate}from\"../utils\";import{ChainSigner}from\"./ChainSigner\";export var CoreChainApiBase=function(){function CoreChainApiBase(){}var _proto=CoreChainApiBase.prototype;_proto.baseGetCurve=function baseGetCurve(curveName){switch(curveName){case'ed25519':return ed25519;case'secp256k1':return secp256k1;case'nistp256':return nistp256;default:throw new OneKeyInternalError('Unsupported curve');}};_proto.baseCreateSigner=function(){var _baseCreateSigner=_asyncToGenerator(function*({curve,privateKey,password}){if(typeof password==='undefined'){throw new OneKeyInternalError('Software signing requires a password.');}var privateKeyBuffer=bufferUtils.toBuffer(privateKey);return Promise.resolve(new ChainSigner(privateKeyBuffer,password,curve));});function baseCreateSigner(_x){return _baseCreateSigner.apply(this,arguments);}return baseCreateSigner;}();_proto.baseGetSingleSigner=function(){var _baseGetSingleSigner=_asyncToGenerator(function*({payload,curve}){var privateKeys=yield this.getPrivateKeys(payload);var accountPath=payload.account.path;var privateKey=privateKeys[accountPath];var firstRelPath=payload?.relPaths?.[0];if(!privateKey&&firstRelPath){var fullPath=[accountPath,firstRelPath].join('/');privateKey=privateKeys[fullPath];}if(!privateKey){throw new Error(`No private key found: ${accountPath}`);}return this.baseCreateSigner({curve,privateKey,password:payload.password});});function baseGetSingleSigner(_x2){return _baseGetSingleSigner.apply(this,arguments);}return baseGetSingleSigner;}();_proto.baseGetPrivateKeys=function(){var _baseGetPrivateKeys=_asyncToGenerator(function*({payload,curve}){var{credentials,account,password,relPaths}=payload;var privateKeys={};if(credentials.hd&&credentials.imported){throw new OneKeyInternalError('getPrivateKeys ERROR: hd and imported credentials can NOT both set.');}if(credentials.hd){privateKeys=yield this.baseGetPrivateKeysHd({curve,account,hdCredential:credentials.hd,password,relPaths});}if(credentials.imported){var{privateKey:p}=decryptImportedCredential({password,credential:credentials.imported});var encryptPrivateKey=bufferUtils.bytesToHex(encrypt(password,p));privateKeys[account.path]=encryptPrivateKey;privateKeys['']=encryptPrivateKey;}if(!Object.keys(privateKeys).length){throw new Error('No private keys found');}return privateKeys;});function baseGetPrivateKeys(_x3){return _baseGetPrivateKeys.apply(this,arguments);}return baseGetPrivateKeys;}();_proto.baseGetPrivateKeysHd=function(){var _baseGetPrivateKeysHd=_asyncToGenerator(function*({curve,password,account,relPaths,hdCredential}){var{path}=account;var pathComponents=path.split('/');var usedRelativePaths=relPaths||[pathComponents.pop()];var basePath=pathComponents.join('/');if(usedRelativePaths.length===0){throw new OneKeyInternalError('getPrivateKeysHd ERROR: relPaths is empty.');}var keys=batchGetPrivateKeys(curve,hdCredential,password,basePath,usedRelativePaths);var map=keys.reduce(function(ret,key){var result=_objectSpread(_objectSpread({},ret),{},{[key.path]:bufferUtils.bytesToHex(key.extendedKey.key)});return result;},{});return map;});function baseGetPrivateKeysHd(_x4){return _baseGetPrivateKeysHd.apply(this,arguments);}return baseGetPrivateKeysHd;}();_proto.baseGetAddressesFromHd=function(){var _baseGetAddressesFromHd=_asyncToGenerator(function*(query,options){var _this=this;var{curve,generateFrom}=options;var{template,hdCredential,password,indexes}=query;var{pathPrefix,pathSuffix}=slicePathTemplate(template);var indexFormatted=indexes.map(function(index){return pathSuffix.replace('{index}',index.toString());});var isPrivateKeyMode=generateFrom==='privateKey';var pubkeyInfos=[];var pvtkeyInfos=[];if(isPrivateKeyMode){pvtkeyInfos=batchGetPrivateKeys(curve,hdCredential,password,pathPrefix,indexFormatted);}else{pubkeyInfos=yield batchGetPublicKeysAsync({curveName:curve,hdCredential,password,prefix:pathPrefix,relPaths:indexFormatted});}var infos=isPrivateKeyMode?pvtkeyInfos:pubkeyInfos;if(infos.length!==indexes.length){throw new OneKeyInternalError('Unable to get publick key.');}var addresses=yield Promise.all(infos.map(function(){var _ref=_asyncToGenerator(function*(info){var{path,extendedKey:{key}}=info;var publicKey;var result;if(isPrivateKeyMode){var privateKeyRaw=bufferUtils.bytesToHex(decrypt(password,key));result=yield _this.getAddressFromPrivate({networkInfo:query.networkInfo,privateKeyRaw,privateKeyInfo:info});}else{publicKey=key.toString('hex');result=yield _this.getAddressFromPublic({networkInfo:query.networkInfo,publicKey,publicKeyInfo:info});}return _merge({publicKey,path},result);});return function(_x7){return _ref.apply(this,arguments);};}()));return{addresses};});function baseGetAddressesFromHd(_x5,_x6){return _baseGetAddressesFromHd.apply(this,arguments);}return baseGetAddressesFromHd;}();_proto.baseGetCredentialsType=function baseGetCredentialsType({credentials}){if(credentials.hd&&credentials.imported){throw new OneKeyInternalError('getCredentialsType ERROR: hd and imported credentials can NOT both set.');}if(credentials.hd){return ECoreCredentialType.hd;}if(credentials.imported){return ECoreCredentialType.imported;}throw new OneKeyInternalError('getCredentialsType ERROR: no credentials found');};_proto.baseGetDefaultPrivateKey=function(){var _baseGetDefaultPrivateKey=_asyncToGenerator(function*(params){var privateKeysMap=yield this.getPrivateKeys(params);var[encryptedPrivateKey]=Object.values(privateKeysMap);return{privateKeyRaw:encryptedPrivateKey};});function baseGetDefaultPrivateKey(_x8){return _baseGetDefaultPrivateKey.apply(this,arguments);}return baseGetDefaultPrivateKey;}();_proto.validateXpub=function(){var _validateXpub=_asyncToGenerator(function*(params){throw new NotImplemented();});function validateXpub(_x9){return _validateXpub.apply(this,arguments);}return validateXpub;}();_proto.validateXprvt=function(){var _validateXprvt=_asyncToGenerator(function*(params){throw new NotImplemented();});function validateXprvt(_x10){return _validateXprvt.apply(this,arguments);}return validateXprvt;}();return _createClass(CoreChainApiBase);}();","import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));}catch(t){}return(_isNativeReflectConstruct=function(){return!!t;})();}import CoreChainSoftware from\"./CoreChainSoftware\";var CoreChainHd=function(_CoreChainSoftware){_inherits(CoreChainHd,_CoreChainSoftware);var _super=_createSuper(CoreChainHd);function CoreChainHd(){return _super.apply(this,arguments);}return _createClass(CoreChainHd);}(CoreChainSoftware);export{CoreChainHd as default};","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context) {\n  if (result === true) ; else if (result === false) {\n    yield context.fail();\n  } else {\n    yield* result;\n  }\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nfunction iteratorShift(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n\n/**\n * `Struct` objects encapsulate the schema for a specific data type (with\n * optional coercion). You can then use the `assert`, `is` or `validate` helpers\n * to validate unknown data against a struct.\n */\n\nclass Struct {\n  constructor(props) {\n    const {\n      type,\n      schema,\n      coercer = value => value,\n      validator = () => [],\n      refiner = () => []\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.coercer = coercer;\n    this.validator = validator;\n    this.refiner = refiner;\n  }\n\n}\n/**\n * `StructError` objects are thrown (or returned) by Superstruct when its\n * validation fails. The error represents the first error encountered during\n * validation. But they also have an `error.failures` property that holds\n * information for all of the failures encountered.\n */\n\nclass StructError extends TypeError {\n  constructor(failure, moreFailures) {\n    const {\n      path,\n      value,\n      type,\n      branch\n    } = failure,\n          rest = _objectWithoutProperties(failure, [\"path\", \"value\", \"type\", \"branch\"]);\n\n    const message = `Expected a value of type \\`${type}\\`${path.length ? ` for \\`${path.join('.')}\\`` : ''} but received \\`${JSON.stringify(value)}\\`.`;\n    let failuresResult;\n\n    function failures() {\n      if (!failuresResult) {\n        failuresResult = [failure, ...moreFailures];\n      }\n\n      return failuresResult;\n    }\n\n    super(message);\n    this.value = value;\n    Object.assign(this, rest);\n    this.type = type;\n    this.path = path;\n    this.branch = branch;\n    this.failures = failures;\n    this.stack = new Error().stack;\n    this.__proto__ = StructError.prototype;\n  }\n\n}\n/**\n * Assert that a value passes a `Struct`, throwing if it doesn't.\n */\n\nfunction assert(value, struct) {\n  const result = validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Coerce a value with the coercion logic of `Struct` and validate it.\n */\n\nfunction coerce(value, struct) {\n  const ret = struct.coercer(value);\n  assert(ret, struct);\n  return ret;\n}\n/**\n * Check if a value passes a `Struct`.\n */\n\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a `Struct`, returning an error if invalid.\n */\n\nfunction validate(value, struct, coercing = false) {\n  if (coercing) {\n    value = struct.coercer(value);\n  }\n\n  const failures = check(value, struct);\n  const failure = iteratorShift(failures);\n\n  if (failure) {\n    const error = new StructError(failure, failures);\n    return [error, undefined];\n  } else {\n    return [undefined, value];\n  }\n}\n/**\n * Check a value against a `Struct`, returning an iterable of failures.\n */\n\nfunction* check(value, struct, path = [], branch = []) {\n  const {\n    type\n  } = struct;\n  const ctx = {\n    value,\n    type,\n    branch,\n    path,\n\n    fail(props = {}) {\n      return _objectSpread2({\n        value,\n        type,\n        path,\n        branch: [...branch, value]\n      }, props);\n    },\n\n    check(v, s, parent, key) {\n      const p = parent !== undefined ? [...path, key] : path;\n      const b = parent !== undefined ? [...branch, parent] : branch;\n      return check(v, s, p, b);\n    }\n\n  };\n  const failures = toFailures(struct.validator(value, ctx), ctx);\n  const failure = iteratorShift(failures);\n\n  if (failure) {\n    yield failure;\n    yield* failures;\n  } else {\n    yield* toFailures(struct.refiner(value, ctx), ctx);\n  }\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n */\n\nfunction coercion(struct, coercer) {\n  const fn = struct.coercer;\n  return new Struct(_objectSpread2(_objectSpread2({}, struct), {}, {\n    coercer: value => {\n      return fn(coercer(value));\n    }\n  }));\n}\n/**\n * Augment a struct to coerce a default value for missing values.\n *\n * Note: You must use `coerce(value, Struct)` on the value before validating it\n * to have the value defaulted!\n */\n\nfunction defaulted(S, fallback, strict) {\n  return coercion(S, x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (x === undefined) {\n      return f;\n    }\n\n    if (strict !== true && isPlainObject(x) && isPlainObject(f)) {\n      const ret = _objectSpread2({}, x);\n\n      let changed = false;\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return x;\n  });\n}\n/**\n * Coerce a value to mask its properties to only that defined in the struct.\n */\n\nfunction masked(S) {\n  return coercion(S, x => {\n    if (!isPlainObject(x)) {\n      return x;\n    }\n\n    const ret = {};\n\n    for (const key in S.schema) {\n      ret[key] = x[key];\n    }\n\n    return ret;\n  });\n}\n/**\n * Check if a value is a plain object.\n */\n\nfunction isPlainObject(value) {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Augment a string or array struct to constrain its length to zero.\n */\n\nfunction empty(S) {\n  return refinement(S, `${S.type} & Empty`, value => {\n    return value.length === 0;\n  });\n}\n/**\n * Augment a string or array struct to constrain its length to being between a\n * minimum and maximum size.\n */\n\nfunction length(S, min, max) {\n  return refinement(S, `${S.type} & Length<${min},${max}>`, value => {\n    return min < value.length && value.length < max;\n  });\n}\n/**\n * Refine a string struct to match a specific regexp pattern.\n */\n\nfunction pattern(S, regexp) {\n  return refinement(S, `${S.type} & Pattern<${regexp.source}>`, value => {\n    return regexp.test(value);\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n */\n\nfunction refinement(struct, type, refiner) {\n  const fn = struct.refiner;\n  return new Struct(_objectSpread2(_objectSpread2({}, struct), {}, {\n    type,\n\n    *refiner(value, fail) {\n      yield* toFailures(fn(value, fail), fail);\n      yield* toFailures(refiner(value, fail), fail);\n    }\n\n  }));\n}\n\n/**\n * Validate any value.\n */\n\nfunction any() {\n  return struct('any', () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: `Array<${Element ? Element.type : 'unknown'}>`,\n    schema: Element,\n    coercer: value => {\n      return Element && Array.isArray(value) ? value.map(v => coerce(v, Element)) : value;\n    },\n\n    *validator(value, ctx) {\n      if (!Array.isArray(value)) {\n        yield ctx.fail();\n        return;\n      }\n\n      if (Element) {\n        for (const [i, v] of value.entries()) {\n          yield* ctx.check(v, Element, value, i);\n        }\n      }\n    }\n\n  });\n}\n/**\n * Validate that boolean values.\n */\n\nfunction boolean() {\n  return struct('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Validate that `Date` values.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nfunction date() {\n  return struct('Date', value => {\n    return value instanceof Date && !isNaN(value.getTime());\n  });\n}\n/**\n * Validate that a value dynamically, determing which struct to use at runtime.\n */\n\nfunction dynamic(fn) {\n  return struct('Dynamic<...>', (value, ctx) => {\n    return ctx.check(value, fn(value, ctx));\n  });\n}\nfunction enums(values) {\n  return struct(`Enum<${values.map(toLiteralString)}>`, value => {\n    return values.includes(value);\n  });\n}\n/**\n * Validate that a value is a function.\n */\n\nfunction func() {\n  return struct('Function', value => {\n    return typeof value === 'function';\n  });\n}\n/**\n * Validate that a value is an instance of a class.\n */\n\nfunction instance(Class) {\n  return struct(`InstanceOf<${Class.name}>`, value => {\n    return value instanceof Class;\n  });\n}\nfunction intersection(Structs) {\n  return struct(Structs.map(s => s.type).join(' & '), function* (value, ctx) {\n    for (const S of Structs) {\n      yield* ctx.check(value, S);\n    }\n  });\n}\n/**\n * Validate a value lazily, by constructing the struct right before the first\n * validation. This is useful for cases where you want to have self-referential\n * structs for nested data structures.\n */\n\nfunction lazy(fn) {\n  let S;\n  return struct('Lazy<...>', (value, ctx) => {\n    if (!S) {\n      S = fn();\n    }\n\n    return ctx.check(value, S);\n  });\n}\nfunction literal(constant) {\n  return struct(`Literal<${toLiteralString(constant)}>`, value => {\n    return value === constant;\n  });\n}\n/**\n * Validate that a value is a map with specific key and value entries.\n */\n\nfunction map(Key, Value) {\n  return struct(`Map<${Key.type},${Value.type}>`, function* (value, ctx) {\n    if (!(value instanceof Map)) {\n      yield ctx.fail();\n      return;\n    }\n\n    for (const [k, v] of value.entries()) {\n      yield* ctx.check(k, Key, value, k);\n      yield* ctx.check(v, Value, value, k);\n    }\n  });\n}\n/**\n * Validate that a value always fails.\n */\n\nfunction never() {\n  return struct('never', () => false);\n}\n/**\n * Augment a struct to make it accept `null` values.\n */\n\nfunction nullable(S) {\n  return new Struct({\n    type: `${S.type} | null`,\n    schema: S.schema,\n    validator: (value, ctx) => {\n      return value === null || ctx.check(value, S);\n    }\n  });\n}\n/**\n * Validate that a value is a number.\n */\n\nfunction number() {\n  return struct(`number`, value => {\n    return typeof value === 'number' && !isNaN(value);\n  });\n}\nfunction object(Structs) {\n  const knowns = Structs ? Object.keys(Structs) : [];\n  const Never = never();\n  return new Struct({\n    type: Structs ? `Object<{${knowns.join(',')}}>` : 'Object',\n    schema: Structs ? Structs : null,\n    coercer: Structs ? createObjectCoercer(Structs) : x => x,\n\n    *validator(value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail();\n        return;\n      }\n\n      if (Structs) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          const Value = Structs[key];\n          const v = value[key];\n          yield* ctx.check(v, Value, value, key);\n        }\n\n        for (const key of unknowns) {\n          const v = value[key];\n          yield* ctx.check(v, Never, value, key);\n        }\n      }\n    }\n\n  });\n}\n/**\n * Augment a struct to make it optionally accept `undefined` values.\n */\n\nfunction optional(S) {\n  return new Struct({\n    type: `${S.type}?`,\n    schema: S.schema,\n    validator: (value, ctx) => {\n      return value === undefined || ctx.check(value, S);\n    }\n  });\n}\n/**\n * Validate that a partial object with specific entry values.\n */\n\nfunction partial(Structs) {\n  if (Structs instanceof Struct) {\n    Structs = Structs.schema;\n  }\n\n  const knowns = Object.keys(Structs);\n  const Never = never();\n  return new Struct({\n    type: `Partial<{${knowns.join(',')}}>`,\n    schema: Structs,\n    coercer: createObjectCoercer(Structs),\n\n    *validator(value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail();\n        return;\n      }\n\n      const unknowns = new Set(Object.keys(value));\n\n      for (const key of knowns) {\n        unknowns.delete(key);\n\n        if (!(key in value)) {\n          continue;\n        }\n\n        const Value = Structs[key];\n        const v = value[key];\n        yield* ctx.check(v, Value, value, key);\n      }\n\n      for (const key of unknowns) {\n        const v = value[key];\n        yield* ctx.check(v, Never, value, key);\n      }\n    }\n\n  });\n}\n/**\n * Validate that a value is a record with specific key and\n * value entries.\n */\n\nfunction record(Key, Value) {\n  return struct(`Record<${Key.type},${Value.type}>`, function* (value, ctx) {\n    if (typeof value !== 'object' || value == null) {\n      yield ctx.fail();\n      return;\n    }\n\n    for (const k in value) {\n      const v = value[k];\n      yield* ctx.check(k, Key, value, k);\n      yield* ctx.check(v, Value, value, k);\n    }\n  });\n}\n/**\n * Validate that a set of values matches a specific type.\n */\n\nfunction set(Element) {\n  return struct(`Set<${Element.type}>`, (value, ctx) => {\n    if (!(value instanceof Set)) {\n      return false;\n    }\n\n    for (const val of value) {\n      const [failure] = ctx.check(val, Element);\n\n      if (failure) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n}\n/**\n * Validate that a value is a string.\n */\n\nfunction string() {\n  return struct('string', value => {\n    return typeof value === 'string';\n  });\n}\n/**\n * Define a `Struct` instance with a type and validation function.\n */\n\nfunction struct(name, validator) {\n  return new Struct({\n    type: name,\n    validator,\n    schema: null\n  });\n}\nfunction tuple(Elements) {\n  const Never = never();\n  return struct(`[${Elements.map(s => s.type).join(',')}]`, function* (value, ctx) {\n    if (!Array.isArray(value)) {\n      yield ctx.fail();\n      return;\n    }\n\n    for (const [index, Element] of Elements.entries()) {\n      const v = value[index];\n      yield* ctx.check(v, Element, value, index);\n    }\n\n    if (value.length > Elements.length) {\n      const index = Elements.length;\n      const v = value[index];\n      yield* ctx.check(v, Never, value, index);\n    }\n  });\n}\n/**\n * Validate that a value matches a specific strutural interface, like the\n * structural typing that TypeScript uses.\n */\n\nfunction type(Structs) {\n  const keys = Object.keys(Structs);\n  return struct(`Type<{${keys.join(',')}}>`, function* (value, ctx) {\n    if (typeof value !== 'object' || value == null) {\n      yield ctx.fail();\n      return;\n    }\n\n    for (const key of keys) {\n      const Value = Structs[key];\n      const v = value[key];\n      yield* ctx.check(v, Value, value, key);\n    }\n  });\n}\nfunction union(Structs) {\n  return struct(`${Structs.map(s => s.type).join(' | ')}`, function* (value, ctx) {\n    for (const S of Structs) {\n      const [...failures] = ctx.check(value, S);\n\n      if (failures.length === 0) {\n        return;\n      }\n    }\n\n    yield ctx.fail();\n  });\n}\n/**\n * Convert a value to a literal string.\n */\n\nfunction toLiteralString(value) {\n  return typeof value === 'string' ? `\"${value.replace(/\"/g, '\"')}\"` : `${value}`;\n}\n/**\n * Coerce the values of an object-like struct.\n */\n\n\nfunction createObjectCoercer(Structs) {\n  const knowns = Object.keys(Structs);\n  return value => {\n    if (typeof value !== 'object' || value == null) {\n      return value;\n    }\n\n    const ret = {};\n    const unknowns = new Set(Object.keys(value));\n\n    for (const key of knowns) {\n      unknowns.delete(key);\n      const Value = Structs[key];\n      const v = value[key];\n      ret[key] = coerce(v, Value);\n    }\n\n    for (const key of unknowns) {\n      ret[key] = value[key];\n    }\n\n    return ret;\n  };\n}\n\nexport { Struct, StructError, any, array, assert, boolean, coerce, coercion, date, defaulted, dynamic, empty, enums, func, instance, intersection, is, lazy, length, literal, map, masked, never, nullable, number, object, optional, partial, pattern, record, refinement, set, string, struct, tuple, type, union, validate };\n//# sourceMappingURL=index.es.js.map\n","import { array, intersection, number, object, optional, pattern, record, refinement, string, type, union } from 'superstruct';\nexport const TYPE_REGEX = /^\\w+/;\nexport const ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\nexport const BYTES_REGEX = /^bytes([0-9]{1,2})$/;\nexport const NUMBER_REGEX = /^u?int([0-9]{0,3})$/;\nexport const STATIC_TYPES = ['address', 'bool', 'bytes', 'string'];\nconst TYPE = refinement(string(), 'Type', (type, context) => {\n  return isValidType(context.branch[0].types, type);\n});\nexport const CIP_23_TYPE = object({\n  name: string(),\n  type: TYPE\n});\nexport const CIP_23_DOMAIN_TYPE = object({\n  name: optional(string()),\n  version: optional(string()),\n  chainId: optional(union([string(), number()])),\n  verifyingContract: optional(pattern(string(), /^0x[0-9a-z]{40}$/i)),\n  salt: optional(union([array(number()), pattern(string(), /^0x[0-9a-z]{64}$/i)]))\n});\nexport const CIP_23_TYPED_DATA_TYPE = object({\n  types: intersection([type({\n    CIP23Domain: array(CIP_23_TYPE)\n  }), record(string(), array(CIP_23_TYPE))]),\n  primaryType: string(),\n  domain: CIP_23_DOMAIN_TYPE,\n  message: object()\n});\nexport const EIP_712_TYPED_DATA_TYPE = object({\n  types: intersection([type({\n    EIP712Domain: array(CIP_23_TYPE)\n  }), record(string(), array(CIP_23_TYPE))]),\n  primaryType: string(),\n  domain: CIP_23_DOMAIN_TYPE,\n  message: object()\n});\nexport const isValidType = (types, type) => {\n  if (STATIC_TYPES.includes(type)) {\n    return true;\n  }\n\n  if (types[type]) {\n    return true;\n  }\n\n  if (type.match(ARRAY_REGEX)) {\n    const match = type.match(TYPE_REGEX);\n\n    if (match) {\n      const innerType = match[0];\n      return isValidType(types, innerType);\n    }\n  }\n\n  const bytesMatch = type.match(BYTES_REGEX);\n\n  if (bytesMatch) {\n    const length = Number(bytesMatch[1]);\n\n    if (length >= 1 && length <= 32) {\n      return true;\n    }\n  }\n\n  const numberMatch = type.match(NUMBER_REGEX);\n\n  if (numberMatch) {\n    const length = Number(numberMatch[1]);\n\n    if (length >= 8 && length <= 256 && length % 8 === 0) {\n      return true;\n    }\n  }\n\n  return false;\n};\n//# sourceMappingURL=types.js.map","import createKeccakHash from 'keccak';\nexport const keccak256 = (data, encoding) => {\n  return createKeccakHash('keccak256').update(data, encoding).digest();\n};\nexport const toBuffer = (data, encoding) => {\n  if (!encoding) {\n    if (data.startsWith('0x')) {\n      return Buffer.from(data.substring(2), 'hex');\n    }\n\n    return Buffer.from(data, 'hex');\n  }\n\n  return Buffer.from(data, encoding);\n};\n//# sourceMappingURL=buffer.js.map","const BUFFER_WIDTH = 32;\nexport const concat = (target, value, position) => {\n  return new Uint8Array([...target.subarray(0, position !== null && position !== void 0 ? position : target.length), ...value, ...target.subarray(position !== null && position !== void 0 ? position : target.length)]);\n};\nexport const concatMultiple = buffers => {\n  return buffers.reduce((target, buffer) => {\n    const array = new Uint8Array(target.length + buffer.length);\n    array.set(target, 0);\n    array.set(buffer, target.length);\n    return array;\n  }, new Uint8Array(0));\n};\nexport const addPadding = (buffer, length = 32) => {\n  const padding = Buffer.alloc(Math.max(length - buffer.length, 0), 0);\n  return concat(buffer, padding);\n};\nexport const toBuffer = value => {\n  if (Buffer.isBuffer(value) || value instanceof Uint8Array) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    const stringValue = value.startsWith('0x') ? value.substring(2) : value;\n    return Buffer.from(stringValue, 'hex');\n  }\n\n  const hex = value.toString(16);\n  return Buffer.from(hex.padStart(BUFFER_WIDTH * 2, '0').slice(0, BUFFER_WIDTH * 2), 'hex');\n};\nexport const toString = value => {\n  if (typeof window !== 'undefined' && window.TextDecoder) {\n    return new TextDecoder('utf-8').decode(value);\n  }\n\n  return new (require('util').TextDecoder)('utf-8').decode(value);\n};\nexport const toNumber = buffer => {\n  const hex = toHex(buffer);\n\n  if (hex.length === 0) {\n    return BigInt(0);\n  }\n\n  return BigInt(`0x${hex}`);\n};\n\nconst numberToHex = value => {\n  return ('0' + value.toString(16)).slice(-2);\n};\n\nexport const toHex = buffer => {\n  return Array.from(buffer).map(numberToHex).join('');\n};\n//# sourceMappingURL=buffer.js.map","import { addPadding, concat, toBuffer, toNumber } from '../utils/buffer';\nexport const encodeBytes = (buffer, value) => {\n  const bufferValue = toBuffer(value);\n  const paddedSize = Math.ceil(bufferValue.byteLength / 32) * 32;\n  return concat(buffer, Buffer.concat([toBuffer(bufferValue.byteLength), addPadding(bufferValue, paddedSize)]));\n};\nexport const decodeBytes = (value, buffer) => {\n  const pointer = Number(toNumber(value.subarray(0, 32)));\n  const length = toNumber(value.subarray(pointer, pointer + 32));\n  return buffer.subarray(32, 32 + Number(length));\n};\n//# sourceMappingURL=bytes.js.map","import { addPadding, concat, toBuffer } from '../utils/buffer';\nconst BYTES_REGEX = /^bytes([0-9]{1,2})$/;\nexport const isFixedBytes = type => {\n  return BYTES_REGEX.test(type);\n};\nexport const getByteLength = type => {\n  var _type$match;\n\n  const bytes = (_type$match = type.match(BYTES_REGEX)) === null || _type$match === void 0 ? void 0 : _type$match[1];\n\n  if (bytes) {\n    const length = Number(bytes);\n\n    if (length <= 0 || length > 32) {\n      throw new Error('Invalid type: length is out of range');\n    }\n\n    return length;\n  }\n\n  throw new Error('Invalid type: no length');\n};\nexport const encodeFixedBytes = (buffer, value, type) => {\n  const length = getByteLength(type);\n  const bufferValue = toBuffer(value);\n\n  if (bufferValue.length > length) {\n    throw new Error(`Buffer is too long, expected ${length}, got ${bufferValue.length}`);\n  }\n\n  return concat(buffer, addPadding(bufferValue));\n};\nexport const decodeFixedBytes = (value, _, type) => {\n  const length = getByteLength(type);\n  return value.subarray(0, length);\n};\n//# sourceMappingURL=fixed-bytes.js.map","import { concat, toBuffer, toNumber } from '../utils/buffer';\nimport { fromTwosComplement, toTwosComplement } from '../utils/twos-complement';\nconst NUMBER_REGEX = /^u?int([0-9]*)?$/;\n\nconst isSigned = type => {\n  return type.startsWith('i');\n};\n\nexport const isNumber = type => {\n  return NUMBER_REGEX.test(type);\n};\nexport const getBitLength = type => {\n  var _type$match$, _type$match;\n\n  const rawBits = (_type$match$ = (_type$match = type.match(NUMBER_REGEX)) === null || _type$match === void 0 ? void 0 : _type$match[1]) !== null && _type$match$ !== void 0 ? _type$match$ : '256';\n  return Number(rawBits);\n};\nexport const inRange = (value, type) => {\n  const bits = BigInt(getBitLength(type));\n\n  if (isSigned(type)) {\n    const maxSignedValue = 2n ** (bits - 1n) - 1n;\n    return value >= -maxSignedValue - 1n && value <= maxSignedValue;\n  }\n\n  const maxValue = 2n ** bits - 1n;\n  return value >= 0n && value <= maxValue;\n};\n\nconst asNumber = value => {\n  if (typeof value === 'bigint') {\n    return value;\n  }\n\n  return BigInt(value);\n};\n\nexport const encodeNumber = (buffer, value, type) => {\n  const numberValue = asNumber(value);\n\n  if (!inRange(numberValue, type)) {\n    throw new Error(`Cannot encode number: value is out of range for type ${type}`);\n  }\n\n  if (isSigned(type)) {\n    return concat(buffer, toTwosComplement(numberValue, 32));\n  }\n\n  return concat(buffer, toBuffer(numberValue));\n};\nexport const decodeNumber = (value, _, type) => {\n  if (isSigned(type)) {\n    return fromTwosComplement(value);\n  }\n\n  return toNumber(value);\n};\n//# sourceMappingURL=number.js.map","import { concat, concatMultiple, toBuffer, toNumber } from '../utils/buffer';\nimport { decodeAddress, encodeAddress } from './address';\nimport { decodeBytes, encodeBytes } from './bytes';\nimport { decodeFixedBytes, encodeFixedBytes, isFixedBytes } from './fixed-bytes';\nimport { decodeNumber, encodeNumber, isNumber } from './number';\nimport { decodeString, encodeString } from './string';\nconst ARRAY_REGEX = /^(.*)\\[]$/;\nexport const isArray = type => {\n  return ARRAY_REGEX.test(type);\n};\nexport const getType = type => {\n  return type.match(ARRAY_REGEX)[1];\n};\nexport const encodeArray = (buffer, values, type) => {\n  if (!isArray(type)) {\n    throw new Error('Invalid type: type is not array');\n  }\n\n  const actualType = getType(type);\n  const length = toBuffer(values.length);\n  const arrayBuffer = concat(buffer, length);\n  return pack(arrayBuffer, values, new Array(values.length).fill(actualType));\n};\nexport const decodeArray = (value, buffer, type) => {\n  if (!isArray(type)) {\n    throw new Error('Invalid type: type is not array');\n  }\n\n  const actualType = getType(type);\n  const pointer = Number(toNumber(value));\n  const length = Number(toNumber(buffer.subarray(pointer, pointer + 32)));\n  const arrayPointer = pointer + 32;\n  const arrayBuffer = buffer.subarray(arrayPointer);\n  return unpack(arrayBuffer, new Array(length).fill(actualType));\n};\nconst parsers = {\n  address: {\n    encode: encodeAddress,\n    decode: decodeAddress\n  },\n  array: {\n    dynamic: true,\n    encode: encodeArray,\n    decode: decodeArray\n  },\n  bytes: {\n    dynamic: true,\n    encode: encodeBytes,\n    decode: decodeBytes\n  },\n  fixedBytes: {\n    encode: encodeFixedBytes,\n    decode: decodeFixedBytes\n  },\n  number: {\n    encode: encodeNumber,\n    decode: decodeNumber\n  },\n  string: {\n    dynamic: true,\n    encode: encodeString,\n    decode: decodeString\n  }\n};\nexport const getParser = type => {\n  if (parsers[type]) {\n    return parsers[type];\n  }\n\n  if (isFixedBytes(type)) {\n    return parsers.fixedBytes;\n  }\n\n  if (isNumber(type) || type === 'bool') {\n    return parsers.number;\n  }\n\n  if (isArray(type)) {\n    return parsers.array;\n  }\n\n  throw new Error(`type \"${type}\" is not supported`);\n};\nexport const pack = (buffer, values, types) => {\n  const {\n    staticBuffer: packedStaticBuffer,\n    dynamicBuffer: packedDynamicBuffer,\n    updateFunctions: packedUpdateFunctions\n  } = types.reduce(({\n    staticBuffer,\n    dynamicBuffer,\n    updateFunctions\n  }, type, index) => {\n    const parser = getParser(type);\n    const value = values[index];\n\n    if (parser.dynamic) {\n      const offset = dynamicBuffer.length;\n      const staticOffset = staticBuffer.length;\n      const newStaticBuffer = concat(staticBuffer, Buffer.alloc(32, 0));\n      const newDynamicBuffer = parser.encode(dynamicBuffer, value, type);\n\n      const update = oldBuffer => {\n        return concatMultiple([oldBuffer.subarray(0, staticOffset), toBuffer(oldBuffer.length + offset), oldBuffer.subarray(staticOffset + 32)]);\n      };\n\n      return {\n        staticBuffer: newStaticBuffer,\n        dynamicBuffer: newDynamicBuffer,\n        updateFunctions: [...updateFunctions, update]\n      };\n    }\n\n    const newBuffer = parser.encode(staticBuffer, value, type);\n    return {\n      staticBuffer: newBuffer,\n      dynamicBuffer,\n      updateFunctions\n    };\n  }, {\n    staticBuffer: new Uint8Array(0),\n    dynamicBuffer: new Uint8Array(0),\n    updateFunctions: []\n  });\n  const updatedStaticBuffer = packedUpdateFunctions.reduce((target, update) => update(target), packedStaticBuffer);\n  return concatMultiple([buffer, updatedStaticBuffer, packedDynamicBuffer]);\n};\nexport function* iterate(buffer, chunkSize) {\n  for (let i = 0; i < buffer.length; i += chunkSize) {\n    yield buffer.slice(i, i + chunkSize);\n  }\n\n  return buffer;\n}\nexport const unpack = (buffer, types) => {\n  const iterator = iterate(buffer, 32);\n  return types.map(type => {\n    const {\n      value,\n      done\n    } = iterator.next();\n\n    if (done) {\n      throw new Error('input data has an invalid length');\n    }\n\n    const parser = getParser(type);\n    return parser.decode(value, buffer, type);\n  });\n};\n//# sourceMappingURL=array.js.map","import { concat, toHex } from '../utils/buffer';\nexport const encodeAddress = (buffer, value) => {\n  if (value.length !== 42) {\n    throw new Error('Invalid address length');\n  }\n\n  const addressBuffer = Buffer.alloc(32);\n  addressBuffer.write(value.substring(2), 12, 'hex');\n  return concat(buffer, addressBuffer);\n};\nexport const decodeAddress = value => {\n  const addressBuffer = value.subarray(-20);\n  return `0x${toHex(addressBuffer)}`;\n};\n//# sourceMappingURL=address.js.map","import { toBuffer } from './buffer';\nexport const fromTwosComplement = buffer => {\n  const bufferValue = toBuffer(buffer);\n  let value = 0n;\n\n  for (const byte of bufferValue) {\n    value = (value << 8n) + BigInt(byte);\n  }\n\n  return BigInt.asIntN(bufferValue.length * 8, value);\n};\nexport const toTwosComplement = (value, length) => {\n  const buffer = new Uint8Array(length);\n\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] = Number(BigInt.asUintN(8, value));\n    value = value >> 8n;\n  }\n\n  return buffer.reverse();\n};\n//# sourceMappingURL=twos-complement.js.map","import { toString } from '../utils/buffer';\nimport { decodeBytes, encodeBytes } from './bytes';\nexport const encodeString = (buffer, value) => {\n  const bufferValue = Buffer.from(value, 'utf8');\n  return encodeBytes(buffer, bufferValue, 'bytes');\n};\nexport const decodeString = (value, buffer) => {\n  return toString(decodeBytes(value, buffer, 'string'));\n};\n//# sourceMappingURL=string.js.map","import { getIdentifier } from './identifier';\nimport { pack, unpack } from './parsers/array';\nimport { concat } from './utils/buffer';\nexport const encode = (input, values) => {\n  const types = input.map(type => {\n    if (typeof type === 'string') {\n      return type;\n    }\n\n    return type.type;\n  });\n  return pack(Buffer.alloc(0), values, types);\n};\nexport const encodeWithIdentifier = (contractFunction, values) => {\n  const identifier = Buffer.from(getIdentifier(contractFunction), 'hex');\n  const encoded = encode(contractFunction.inputs, values);\n  return concat(identifier, encoded);\n};\nexport const decode = (input, buffer) => {\n  const types = input.map(type => {\n    if (typeof type === 'string') {\n      return type;\n    }\n\n    return type.type;\n  });\n  return unpack(buffer, types);\n};\n//# sourceMappingURL=abi.js.map","import cfxAddress from '@conflux-dev/conflux-address-js';\nimport { encode as encodeAbi } from '@findeth/abi';\nconst ADDRESS = 'address';\nexport const encode = (types, values) => {\n  values.map(function (v, i, origin) {\n    if (types[i] === ADDRESS) {\n      origin[i] = normalizeAddress(v);\n    }\n  });\n  return Buffer.from(encodeAbi(types, values));\n};\n\nfunction normalizeAddress(address) {\n  if (!cfxAddress.hasNetworkPrefix(address)) {\n    return address;\n  }\n\n  return '0x' + cfxAddress.decode(address).hexAddress.toString('hex');\n}\n//# sourceMappingURL=abi.js.map","import { ARRAY_REGEX, TYPE_REGEX } from './types';\nimport { keccak256, toBuffer, validateTypedData, encode } from './utils';\nconst EIP_191_PREFIX = Buffer.from('1901', 'hex');\nexport const getDependencies = (typedData, type, dependencies = []) => {\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  const match = type.match(TYPE_REGEX);\n  const actualType = match[0];\n\n  if (dependencies.includes(actualType)) {\n    return dependencies;\n  }\n\n  if (!typedData.types[actualType]) {\n    return dependencies;\n  }\n\n  return [actualType, ...typedData.types[actualType].reduce((previous, type) => {\n    const newDependencies = actualType === type.type ? [] : getDependencies(typedData, type.type, previous).filter(dependency => !previous.includes(dependency));\n    return [...previous, ...newDependencies];\n  }, [])];\n};\nexport const encodeType = (typedData, type) => {\n  const [primary, ...dependencies] = getDependencies(typedData, type);\n  const types = [primary, ...dependencies.sort()];\n  return types.map(dependency => {\n    return `${dependency}(${typedData.types[dependency].map(type => `${type.type} ${type.name}`)})`;\n  }).join('');\n};\nexport const getTypeHash = (typedData, type) => {\n  return keccak256(encodeType(typedData, type), 'utf8');\n};\n\nconst encodeValue = (typedData, type, data) => {\n  const match = type.match(ARRAY_REGEX);\n\n  if (match) {\n    const arrayType = match[1];\n    const length = Number(match[2]) || undefined;\n\n    if (!Array.isArray(data)) {\n      throw new Error('Cannot encode data: value is not of array type');\n    }\n\n    if (length && data.length !== length) {\n      throw new Error(`Cannot encode data: expected length of ${length}, but got ${data.length}`);\n    }\n\n    const encodedData = data.map(item => encodeValue(typedData, arrayType, item));\n    const types = encodedData.map(item => item[0]);\n    const values = encodedData.map(item => item[1]);\n    return ['bytes32', keccak256(encode(types, values))];\n  }\n\n  if (typedData.types[type]) {\n    return ['bytes32', getStructHash(typedData, type, data)];\n  }\n\n  if (type === 'string') {\n    return ['bytes32', keccak256(data, 'utf8')];\n  }\n\n  if (type === 'bytes') {\n    return ['bytes32', keccak256(Buffer.isBuffer(data) ? data : toBuffer(data), 'hex')];\n  }\n\n  return [type, data];\n};\n\nexport const encodeData = (typedData, type, data) => {\n  const [types, values] = typedData.types[type].reduce(([types, values], field) => {\n    if (data[field.name] === undefined || data[field.name] === null) {\n      return [[...types, 'bytes32'], [...values, '0x0000000000000000000000000000000000000000000000000000000000000000']];\n    }\n\n    const value = data[field.name];\n    const [type, encodedValue] = encodeValue(typedData, field.type, value);\n    return [[...types, type], [...values, encodedValue]];\n  }, [['bytes32'], [getTypeHash(typedData, type)]]);\n  return encode(types, values);\n};\nexport const getStructHash = (typedData, type, data) => {\n  return keccak256(encodeData(typedData, type, data));\n};\nexport const getMessage = (typedData, hash, domainName = 'CIP23Domain') => {\n  const message = Buffer.concat([EIP_191_PREFIX, getStructHash(typedData, domainName, typedData.domain), getStructHash(typedData, typedData.primaryType, typedData.message)]);\n\n  if (hash) {\n    return keccak256(message);\n  }\n\n  return message;\n};\nexport const asArray = (typedData, type = typedData.primaryType, data = typedData.message) => {\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  if (!typedData.types[type]) {\n    throw new Error('Cannot get data as array: type does not exist');\n  }\n\n  return typedData.types[type].reduce((array, {\n    name,\n    type\n  }) => {\n    if (typedData.types[type]) {\n      if (!data[name]) {\n        throw new Error(`Cannot get data as array: missing data for '${name}'`);\n      }\n\n      return [...array, asArray(typedData, type, data[name])];\n    }\n\n    const value = data[name];\n    return [...array, value];\n  }, []);\n};\n//# sourceMappingURL=cip-23.js.map","import { is } from 'superstruct';\nimport { CIP_23_TYPED_DATA_TYPE, EIP_712_TYPED_DATA_TYPE } from '../types';\nexport const validateTypedData = data => {\n  return is(data, CIP_23_TYPED_DATA_TYPE) || is(data, EIP_712_TYPED_DATA_TYPE);\n};\n//# sourceMappingURL=json.js.map","import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));}catch(t){}return(_isNativeReflectConstruct=function(){return!!t;})();}import{keccak256}from'@ethersproject/keccak256';import{getMessage}from'cip-23';import{decrypt,secp256k1,uncompressPublicKey}from'@onekeyhq/core/src/secret';import{checkIsDefined}from'@onekeyhq/shared/src/utils/assertUtils';import bufferUtils from'@onekeyhq/shared/src/utils/bufferUtils';import{EMessageTypesEth}from'@onekeyhq/shared/types/message';import{CoreChainApiBase}from\"../../base/CoreChainApiBase\";import{ECoreApiExportedSecretKeyType}from\"../../types\";import{pubkeyToCfxAddress,signTransactionWithSigner}from\"./sdkCfx\";import{conflux}from\"./sdkCfx/conflux\";var curve='secp256k1';var{Message,PersonalMessage}=conflux;function hashCfxMessage(typedMessage){var{type,message}=typedMessage;switch(type){case undefined:case EMessageTypesEth.ETH_SIGN:return new Message(message).hash;case EMessageTypesEth.PERSONAL_SIGN:return new PersonalMessage(message).hash;case EMessageTypesEth.TYPED_DATA_V3:case EMessageTypesEth.TYPED_DATA_V4:return keccak256(getMessage(JSON.parse(message)));default:throw new Error(`Invalid messageType: ${type}`);}}var CoreChainSoftware=function(_CoreChainApiBase){_inherits(CoreChainSoftware,_CoreChainApiBase);var _super=_createSuper(CoreChainSoftware);function CoreChainSoftware(){return _super.apply(this,arguments);}var _proto=CoreChainSoftware.prototype;_proto.getExportedSecretKey=function(){var _getExportedSecretKey=_asyncToGenerator(function*(query){var{password,keyType,credentials}=query;var{privateKeyRaw}=yield this.baseGetDefaultPrivateKey(query);if(!privateKeyRaw){throw new Error('privateKeyRaw is required');}if(keyType===ECoreApiExportedSecretKeyType.privateKey){return`0x${decrypt(password,privateKeyRaw).toString('hex')}`;}throw new Error(`SecretKey type not support: ${keyType}`);});function getExportedSecretKey(_x){return _getExportedSecretKey.apply(this,arguments);}return getExportedSecretKey;}();_proto.getPrivateKeys=function(){var _getPrivateKeys=_asyncToGenerator(function*(payload){return this.baseGetPrivateKeys({payload,curve});});function getPrivateKeys(_x2){return _getPrivateKeys.apply(this,arguments);}return getPrivateKeys;}();_proto.signTransaction=function(){var _signTransaction=_asyncToGenerator(function*(payload){var{unsignedTx}=payload;var signer=yield this.baseGetSingleSigner({payload,curve});return signTransactionWithSigner(unsignedTx,signer);});function signTransaction(_x3){return _signTransaction.apply(this,arguments);}return signTransaction;}();_proto.signMessage=function(){var _signMessage=_asyncToGenerator(function*(payload){var unsignedMsg=payload.unsignedMsg;var signer=yield this.baseGetSingleSigner({payload,curve});return Message.sign(`0x${(yield signer.getPrvkey()).toString('hex')}`,hashCfxMessage(unsignedMsg));});function signMessage(_x4){return _signMessage.apply(this,arguments);}return signMessage;}();_proto.getAddressFromPrivate=function(){var _getAddressFromPrivate=_asyncToGenerator(function*(query){var{privateKeyRaw}=query;var privateKey=bufferUtils.toBuffer(privateKeyRaw);var pub=secp256k1.publicFromPrivate(privateKey);return this.getAddressFromPublic({publicKey:bufferUtils.bytesToHex(pub),networkInfo:query.networkInfo});});function getAddressFromPrivate(_x5){return _getAddressFromPrivate.apply(this,arguments);}return getAddressFromPrivate;}();_proto.getAddressFromPublic=function(){var _getAddressFromPublic=_asyncToGenerator(function*(query){var{publicKey}=query;var compressedPublicKey=bufferUtils.toBuffer(publicKey);var uncompressedPublicKey=uncompressPublicKey(curve,compressedPublicKey);var{chainId,networkId}=checkIsDefined(query.networkInfo);var cfxAddress=yield pubkeyToCfxAddress(uncompressedPublicKey,checkIsDefined(chainId));return Promise.resolve({address:'',addresses:{[checkIsDefined(networkId)]:cfxAddress},publicKey});});function getAddressFromPublic(_x6){return _getAddressFromPublic.apply(this,arguments);}return getAddressFromPublic;}();_proto.getAddressesFromHd=function(){var _getAddressesFromHd=_asyncToGenerator(function*(query){return this.baseGetAddressesFromHd(query,{curve});});function getAddressesFromHd(_x7){return _getAddressesFromHd.apply(this,arguments);}return getAddressesFromHd;}();return _createClass(CoreChainSoftware);}(CoreChainApiBase);export{CoreChainSoftware as default};","import coinselectUtils from'coinselect/utils';import accountUtils from'@onekeyhq/shared/src/utils/accountUtils';export function slicePathTemplate(template){return accountUtils.slicePathTemplate(template);}export function getUtxoAccountPrefixPath({fullPath}){var pathComponent=fullPath.split('/');pathComponent.pop();pathComponent.pop();var prefixPath=pathComponent.join('/');return prefixPath;}export function getBIP44Path(account,address){var realPath='';for(var[key,value]of Object.entries(account.addresses)){if(value===address){realPath=key;break;}}return`${account.path}/${realPath}`;}export function estimateTxSize(inputsForCoinSelect,outputsForCoinSelect){return coinselectUtils.transactionBytes(inputsForCoinSelect,outputsForCoinSelect);}","// baseline estimates, used to improve performance\nvar TX_EMPTY_SIZE = 4 + 1 + 1 + 4\nvar TX_INPUT_BASE = 32 + 4 + 1 + 4\nvar TX_INPUT_PUBKEYHASH = 107\nvar TX_OUTPUT_BASE = 8 + 1\nvar TX_OUTPUT_PUBKEYHASH = 25\nvar OP_RETURN_OVERHEAD = 1 + 8 + 1\n\nfunction inputBytes (input) {\n  return TX_INPUT_BASE + (input.script ? input.script.length : TX_INPUT_PUBKEYHASH)\n}\n\nfunction outputBytes (output) {\n  if (output.script) {\n    return OP_RETURN_OVERHEAD + output.script.length + (output.script.length >= 74 ? 2 : 1);\n  }\n  return TX_OUTPUT_BASE + (output.script ? output.script.length : TX_OUTPUT_PUBKEYHASH)\n}\n\nfunction dustThreshold (output, feeRate) {\n  /* ... classify the output for input estimate  */\n  return inputBytes({}) * 3\n}\n\nfunction transactionBytes (inputs, outputs) {\n  return TX_EMPTY_SIZE +\n    inputs.reduce(function (a, x) { return a + inputBytes(x) }, 0) +\n    outputs.reduce(function (a, x) { return a + outputBytes(x) }, 0)\n}\n\nfunction uintOrNaN (v) {\n  if (typeof v !== 'number') return NaN\n  if (!isFinite(v)) return NaN\n  if (Math.floor(v) !== v) return NaN\n  if (v < 0) return NaN\n  return v\n}\n\nfunction sumForgiving (range) {\n  return range.reduce(function (a, x) { return a + (isFinite(x.value) ? x.value : 0) }, 0)\n}\n\nfunction sumOrNaN (range) {\n  return range.reduce(function (a, x) { return a + uintOrNaN(x.value) }, 0)\n}\n\nvar BLANK_OUTPUT = outputBytes({})\n\nfunction finalize (inputs, outputs, feeRate) {\n  var bytesAccum = transactionBytes(inputs, outputs)\n  var feeAfterExtraOutput = feeRate * (bytesAccum + BLANK_OUTPUT)\n  var remainderAfterExtraOutput = sumOrNaN(inputs) - (sumOrNaN(outputs) + feeAfterExtraOutput)\n\n  // is it worth a change output?\n  if (remainderAfterExtraOutput > dustThreshold({}, feeRate)) {\n    outputs = outputs.concat({ value: remainderAfterExtraOutput })\n  }\n\n  var fee = sumOrNaN(inputs) - sumOrNaN(outputs)\n  if (!isFinite(fee)) return { fee: feeRate * bytesAccum }\n\n  return {\n    inputs: inputs,\n    outputs: outputs,\n    fee: fee\n  }\n}\n\nmodule.exports = {\n  dustThreshold: dustThreshold,\n  finalize: finalize,\n  inputBytes: inputBytes,\n  outputBytes: outputBytes,\n  sumOrNaN: sumOrNaN,\n  sumForgiving: sumForgiving,\n  transactionBytes: transactionBytes,\n  uintOrNaN: uintOrNaN\n}\n"],"names":["_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","result","Super","NewTarget","this","constructor","Reflect","construct","arguments","apply","t","Boolean","prototype","valueOf","call","ChainSigner","_Verifier","_super","encryptedPrivateKey","password","curve","_this","pub","N","key","chainCode","Buffer","alloc","toString","_getPrvkeyHex","_proto2","getPrvkey","Promise","resolve","getPrvkeyHex","bufferUtils","bytesToHex","sign","digest","signature","slice","length","Verifier","compressedPublicKey","from","uncompressedPublicKey","_getPubkeyHex","_proto","getPubkey","compressed","getPubkeyHex","_x","verify","verifySignature","publicKey","p","toBuffer","d","s","ownKeys","e","r","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","_objectSpread","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","CoreChainApiBase","_baseCreateSigner","_baseGetSingleSigner","_baseGetPrivateKeys","_baseGetPrivateKeysHd","_baseGetAddressesFromHd","_baseGetDefaultPrivateKey","_validateXpub","_validateXprvt","baseGetCurve","curveName","baseCreateSigner","privateKey","privateKeyBuffer","baseGetSingleSigner","payload","privateKeys","getPrivateKeys","accountPath","account","path","firstRelPath","relPaths","join","Error","_x2","baseGetPrivateKeys","credentials","hd","imported","baseGetPrivateKeysHd","hdCredential","credential","encryptPrivateKey","_x3","pathComponents","split","usedRelativePaths","pop","basePath","reduce","ret","extendedKey","_x4","baseGetAddressesFromHd","query","options","generateFrom","template","indexes","pathPrefix","pathSuffix","indexFormatted","map","index","replace","isPrivateKeyMode","pubkeyInfos","pvtkeyInfos","prefix","infos","_ref","addresses","all","info","privateKeyRaw","getAddressFromPrivate","networkInfo","privateKeyInfo","getAddressFromPublic","publicKeyInfo","_x7","_x5","_x6","baseGetCredentialsType","ECoreCredentialType","baseGetDefaultPrivateKey","params","privateKeysMap","values","_x8","validateXpub","_x9","validateXprvt","_x10","CoreChainHd","_CoreChainSoftware","_defineProperty","obj","value","configurable","writable","object","enumerableOnly","symbols","sym","_objectSpread2","target","i","source","_objectWithoutProperties","excluded","_objectWithoutPropertiesLoose","sourceKeys","indexOf","sourceSymbolKeys","propertyIsEnumerable","toFailures","context","fail","iteratorShift","input","done","next","undefined","Struct","props","type","schema","coercer","validator","refiner","StructError","TypeError","failure","moreFailures","branch","rest","failuresResult","super","JSON","stringify","assign","failures","stack","__proto__","coerce","struct","assert","validate","is","coercing","check","ctx","v","parent","pattern","S","regexp","refinement","test","fn","array","Element","Array","isArray","entries","intersection","Structs","never","number","isNaN","knowns","Never","createObjectCoercer","x","unknowns","Set","delete","Value","optional","record","Key","k","string","name","union","TYPE_REGEX","ARRAY_REGEX","BYTES_REGEX","NUMBER_REGEX","STATIC_TYPES","TYPE","isValidType","types","CIP_23_TYPE","CIP_23_DOMAIN_TYPE","version","chainId","verifyingContract","salt","CIP_23_TYPED_DATA_TYPE","CIP23Domain","primaryType","domain","message","EIP_712_TYPED_DATA_TYPE","EIP712Domain","includes","match","innerType","bytesMatch","Number","numberMatch","keccak256","data","encoding","update","startsWith","substring","position","Uint8Array","subarray","concatMultiple","buffers","buffer","set","addPadding","padding","Math","max","isBuffer","stringValue","hex","padStart","BUFFER_WIDTH","toNumber","toHex","BigInt","numberToHex","encodeBytes","bufferValue","paddedSize","ceil","byteLength","concat","decodeBytes","pointer","getByteLength","_type$match","bytes","isSigned","inRange","bits","_type$match$","rawBits","getBitLength","maxSignedValue","getType","parsers","address","encode","addressBuffer","write","decode","dynamic","actualType","arrayBuffer","pack","fill","arrayPointer","fixedBytes","_","numberValue","asNumber","asUintN","reverse","toTwosComplement","byte","asIntN","fromTwosComplement","window","TextDecoder","getParser","isFixedBytes","isNumber","staticBuffer","packedStaticBuffer","dynamicBuffer","packedDynamicBuffer","updateFunctions","packedUpdateFunctions","parser","offset","staticOffset","oldBuffer","updatedStaticBuffer","iterator","iterate","chunkSize","origin","normalizeAddress","hexAddress","EIP_191_PREFIX","getDependencies","typedData","dependencies","previous","newDependencies","dependency","getTypeHash","primary","sort","encodeType","encodeValue","arrayType","encodedData","item","getStructHash","field","encodedValue","encodeData","Message","PersonalMessage","conflux","hashCfxMessage","typedMessage","ETH_SIGN","hash","PERSONAL_SIGN","TYPED_DATA_V3","TYPED_DATA_V4","domainName","getMessage","parse","CoreChainSoftware","_CoreChainApiBase","_getExportedSecretKey","_getPrivateKeys","_signTransaction","_signMessage","_getAddressFromPrivate","_getAddressFromPublic","_getAddressesFromHd","getExportedSecretKey","keyType","ECoreApiExportedSecretKeyType","signTransaction","unsignedTx","signer","signMessage","unsignedMsg","publicFromPrivate","networkId","cfxAddress","getAddressesFromHd","slicePathTemplate","getUtxoAccountPrefixPath","fullPath","pathComponent","getBIP44Path","realPath","estimateTxSize","inputsForCoinSelect","outputsForCoinSelect","TX_EMPTY_SIZE","TX_INPUT_BASE","TX_INPUT_PUBKEYHASH","TX_OUTPUT_BASE","TX_OUTPUT_PUBKEYHASH","OP_RETURN_OVERHEAD","inputBytes","script","outputBytes","output","dustThreshold","feeRate","transactionBytes","inputs","outputs","a","uintOrNaN","NaN","isFinite","floor","sumOrNaN","range","BLANK_OUTPUT","module","exports","finalize","bytesAccum","feeAfterExtraOutput","remainderAfterExtraOutput","fee","sumForgiving"],"sourceRoot":""}